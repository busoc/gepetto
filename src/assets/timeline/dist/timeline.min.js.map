{"version":3,"sources":["webpack:///webpack/bootstrap 3d8be3631f4b18d1d330","webpack:///./src/tags.js","webpack:///./src/utils.js","webpack:///./src/core/Band.js","webpack:///./src/Timeline.js","webpack:///./src/core/index.js","webpack:///./src/space/index.js","webpack:///./src/theme/index.js","webpack:///./src/VDom.js","webpack:///./src/Viewport.js","webpack:///./src/core/EventBand.js","webpack:///./src/core/EventTracker.js","webpack:///./src/core/LocationTracker.js","webpack:///./src/core/NoDataZone.js","webpack:///./src/core/SpacerBand.js","webpack:///./src/core/Timescale.js","webpack:///./src/core/WallclockLocator.js","webpack:///./src/index.js","webpack:///./src/space/AttitudeBand.js","webpack:///./src/space/CommsBand.js","webpack:///./src/space/DayNightBackgroundAddon.js","webpack:///./src/space/DayNightBand.js","webpack:///./src/space/OrbitNumberBand.js","webpack:///./src/space/SaaBand.js","webpack:///./src/theme/baseTheme.js","webpack:///./src/theme/darkTheme.js"],"names":[],"mappings":"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","file":"timeline.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 16);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 3d8be3631f4b18d1d330","export class Tag {\n    constructor(name, attributes, child) {\n        this.name = name\n        this.children = []\n        this.attributes = attributes || {}\n        if (child) {\n            this.addChild(child)\n        }\n    }\n\n    /**\n     * Adds one or more child tags to this parent tag\n     * @param {(Object|Object[])} - A child element, or an array of children\n     */\n    addChild(child) {\n        if (Array.isArray(child)) {\n            for (let c of child) {\n                this.children.push(c)\n            }\n        } else {\n            this.children.push(child)\n        }\n    }\n\n    setAttribute(key, value) {\n        this.attributes[key] = value\n    }\n}\n\nexport class ClipPath extends Tag {\n    constructor(attributes, child) {\n        super('clipPath', attributes, child)\n    }\n}\n\nexport class Defs extends Tag {\n    constructor(attributes, child) {\n        super('defs', attributes, child)\n    }\n}\n\nexport class Desc extends Tag {\n    constructor(attributes, child) {\n        super('desc', attributes, child)\n    }\n}\n\nexport class Ellipse extends Tag {\n    constructor(attributes, child) {\n        super('ellipse', attributes, child)\n    }\n}\n\nexport class G extends Tag {\n    constructor(attributes, child) {\n        super('g', attributes, child)\n    }\n}\n\nexport class Line extends Tag {\n    constructor(attributes, child) {\n        super('line', attributes, child)\n    }\n}\n\nexport class Path extends Tag {\n    constructor(attributes, child) {\n        super('path', attributes, child)\n    }\n}\n\nexport class Pattern extends Tag {\n    constructor(attributes, child) {\n        super('pattern', attributes, child)\n    }\n}\n\nexport class RadialGradient extends Tag {\n    constructor(attributes, child) {\n        super('radialGradient', attributes, child)\n    }\n}\n\nexport class Rect extends Tag {\n    constructor(attributes, child) {\n        super('rect', attributes, child)\n    }\n}\n\nexport class Set extends Tag {\n    constructor(attributes, child) {\n        super('set', attributes, child)\n    }\n}\n\nexport class Stop extends Tag {\n    constructor(attributes, child) {\n        super('stop', attributes, child)\n    }\n}\n\nexport class Svg extends Tag {\n    constructor(attributes, child) {\n        super('svg', attributes, child)\n    }\n}\n\nexport class Text extends Tag {\n    constructor(attributes, child) {\n        super('text', attributes, child)\n    }\n}\n\nexport class Title extends Tag {\n    constructor(attributes, child) {\n        super('title', attributes, child)\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/tags.js","/*global moment */\n\nfunction leftPad(nr, n) {\n    return Array(n - String(nr).length + 1).join('0') + nr\n}\n\nexport function toDate(obj) {\n    if (!obj) return obj\n\n    if (obj instanceof Date) {\n        return obj\n    } else if (typeof obj === 'number') {\n        return new Date(obj)\n    } else if (typeof obj === 'string') {\n        return new Date(Date.parse(obj))\n    } else if (moment && moment.isMoment(obj)) {\n        return obj.toDate()\n    }\n}\n\nexport function addDays(date, days) {\n    let result = new Date(date.getTime())\n    result.setDate(result.getDate() + days)\n    return result\n}\n\nexport function addSeconds(date, seconds) {\n    return new Date(date.getTime() + (seconds * 1000))\n}\n\nexport function addMillis(date, millis) {\n    return new Date(date.getTime() + millis)\n}\n\nexport function millisBetween(date1, date2) {\n    return date2.getTime() - date1.getTime()\n}\n\nexport function isBefore(date1, date2) {\n    return date1.getTime() < date2.getTime()\n}\n\nexport function isAfter(date1, date2) {\n    return date1.getTime() > date2.getTime()\n}\n\nexport function isBetween(date, intvStart, intvStop) {\n    return intvStart.getTime() <= date.getTime() <= intvStop.getTime()\n}\n\nexport function startOfHour(date) {\n    let truncated = new Date(date.getTime())\n    truncated.setMinutes(0, 0, 0)\n    return truncated\n}\n\nexport function startOfDay(date, tz) {\n    let utc = (tz === 'GMT' || tz === 'UTC')\n    let truncated = new Date(date.getTime())\n    if (utc) {\n        truncated.setUTCHours(0, 0, 0, 0)\n    } else {\n        truncated.setHours(0, 0, 0, 0)\n    }\n    return truncated\n}\n\nexport function startOfWeek(date, tz) {\n    let utc = (tz === 'GMT' || tz === 'UTC')\n    let truncated = startOfDay(date, tz)\n    if (utc) {\n        let day = truncated.getUTCDay() || 7 // Turn Sunday into 7\n        if (day !== 1) {\n            truncated.setUTCHours(-24 * (day - 1))\n        }\n    } else {\n        let day = truncated.getDay() || 7 // Turn Sunday into 7\n        if (day !== 1) {\n            truncated.setHours(-24 * (day - 1))\n        }\n    }\n    return truncated\n}\n\nexport function startOfMonth(date, tz) {\n    let utc = (tz === 'GMT' || tz === 'UTC')\n    let truncated = new Date(date.getTime())\n    if (utc) {\n        truncated.setUTCDate(1)\n        truncated.setUTCHours(0, 0, 0, 0)\n    } else {\n        truncated.setDate(1)\n        truncated.setHours(0, 0, 0, 0)\n    }\n    return truncated\n}\n\nexport function startOfYear(date, tz) {\n    let utc = (tz === 'GMT' || tz === 'UTC')\n    if (utc) {\n        return new Date(Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0))\n    } else {\n        return new Date(date.getFullYear(), 0, 1, 0, 0, 0, 0)\n    }\n}\n\nexport function isLeapYear(date, utc) {\n    let year = (utc ? date.getUTCFullYear() : date.getFullYear())\n    if ((year & 3) !== 0) return false\n    return ((year % 100) !== 0 || (year % 400) === 0)\n}\n\nexport function formatDate(date, format, tz) {\n    let utc = (tz === 'GMT' || tz === 'UTC')\n    if (tz && !utc) {\n        throw `Unsupported timezone '${tz}'`\n    }\n\n    if (format === 'YYYY') {\n        return (utc ? date.getUTCFullYear() : date.getFullYear())\n    } else if (format === 'MM') {\n        let m = (utc ? date.getUTCMonth() : date.getMonth()) + 1\n        return (m < 10) ? '0' + m : ' ' + m\n    } else if (format === 'MMM') {\n        let monthAbbr = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\n        let m = (utc ? date.getUTCMonth() : date.getMonth())\n        return monthAbbr[m]\n    } else if (format === 'MMMM') {\n        let months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']\n        let m = (utc ? date.getUTCMonth() : date.getMonth())\n        return months[m]\n    } else if (format === 'DD') {\n        let d = (utc ? date.getUTCDate() : date.getDate())\n        return (d < 10) ? '0' + d : ' ' + d\n    } else if (format === 'DDDD') { // Day of year\n        let dayCount = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334]\n        let m = (utc ? date.getUTCMonth() : date.getMonth())\n        let d = (utc ? date.getUTCDate() : date.getDate())\n        let dayOfYear = dayCount[m] + d\n        if (m > 1 && isLeapYear(date, utc)) dayOfYear++\n        return leftPad(dayOfYear, 3)\n    } else if (format === 'dd') { // Day of week\n        let weekAbbr = ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa']\n        return weekAbbr[utc ? date.getUTCDay() : date.getDay()]\n    } else if (format === 'ddd') { // Day of week\n        let weekAbbr = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']\n        return weekAbbr[utc ? date.getUTCDay() : date.getDay()]\n    } else if (format === 'Do') {\n        let d = (utc ? date.getUTCDate() : date.getDate())\n        return (d === 1 || d === 31) ? d + 'st' : (d === 2) ? d + 'nd' : d + 'th'\n    } else if (format === 'HH') {\n        let h = (utc ? date.getUTCHours() : date.getHours())\n        return (h < 10) ? '0' + h : '' + h\n    } else {\n        throw `Unexpected format '${format}'`\n    }\n}\n\n/**\n *  Returns the rendered pixel width of the element.\n *  This does not include margin, padding or borders.\n */\nexport function getWidth(el) {\n    // should maybe use offsetWidth\n    return el.getBoundingClientRect().width\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils.js","import { Rect, Set, Text } from '../tags'\n\n\nexport default class Band {\n\n    constructor(timeline, opts, style) {\n        this.timeline = timeline\n        this.opts = opts\n        this.style = style\n\n        this.interactive = (opts.interactive === true)\n    }\n\n    get height() {\n        return this.style['bandHeight']\n    }\n\n    renderBand(ctx) {\n        return [\n            new Rect({\n                x: ctx.x,\n                y: ctx.y,\n                width: '100%',\n                height: this.height,\n                fill: this.style['bandBackgroundColor'],\n                //stroke: '#aaa',\n                //'stroke-width': 1,\n                //filter: this.style['bandBackgroundFilter'],\n            }), new Rect({\n                x: ctx.x,\n                y: ctx.y + this.height,\n                width: '100%',\n                height: 1,\n                style: 'fill: #aaa',\n            }),\n        ]\n    }\n\n    renderSidebar(ctx) {\n        let res = [\n            new Rect({\n                x: ctx.x,\n                y: ctx.y,\n                width: this.style['sidebarWidth'],\n                height: this.height + ctx.paddingTop + ctx.paddingBottom,\n                cursor: 'default',\n                fill: this.style['sidebarBackgroundColor'],\n                filter: this.style['sidebarBackgroundFilter'],\n            }),\n        ]\n\n        if (this.opts['label']) {\n            let label = new Text({\n                x: ctx.x + 5,\n                y: ctx.y + ctx.paddingTop + (this.height / 2),\n                cursor: 'default',\n                fill: this.style['sidebarForegroundColor'],\n                'text-anchor': 'left',\n                'dominant-baseline': 'middle',\n                'font-size': this.style['textSize'],\n            }, this.opts['label'] || 'Untitled')\n\n            if (this.interactive) {\n                label.setAttribute('cursor', 'pointer')\n                label.addChild(new Set({\n                    attributeName: 'opacity',\n                    to: this.style['highlightOpacity'],\n                    begin: 'mouseover',\n                    end: 'mouseout',\n                }))\n            }\n            res.push(label)\n        }\n\n        return res\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/Band.js","import * as utils from './utils'\nimport VDom from './VDom'\nimport Viewport from './Viewport'\n\n\nexport default class Timeline {\n\n    constructor(el, opts, plugins, themes) {\n        this.containerEl = el\n        this.plugins = plugins\n        this.themes = themes\n        this.contributions = []\n        this.eventListeners = {\n            // Basic\n            click: [],\n            mouseenter: [],\n            mouseleave: [],\n            mousemove: [],\n            // Custom\n            loadRange: [],\n            eventClick: [],\n            eventMouseEnter: [],\n            eventMouseMove: [],\n            eventMouseLeave: [],\n            hover: [],\n            panStart: [],\n            panStop: [],\n            viewportChange: [],\n            viewportChanged: [],\n            viewportWheel: [],\n        }\n        this.targetsById = {} // Index to couple events back with a user object\n        this.mouseEnteredTarget = undefined // Target currently under mouse\n\n        // Invisible SVG used to measure font metrics before rendering actual timeline svg\n        this.measurerSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg')\n        this.measurerSvg.setAttribute('height', 0)\n        this.measurerSvg.setAttribute('width', 0)\n        this.measurerSvg.setAttribute('style', 'visibility: hidden')\n        this.containerEl.appendChild(this.measurerSvg)\n\n        // Target width (incl. sidebar)\n        // Not exposed as an option, because user should size using containerEl\n        this.width = utils.getWidth(this.containerEl)\n\n        this.updateOptions(opts, false /* no draw */)\n    }\n\n    static get minZoom() {\n        return 1\n    }\n\n    static get defaultZoom() {\n        return 12\n    }\n\n    static get maxZoom() {\n        return 14\n    }\n\n    getFontMetrics(textString, textSize) {\n        let el = document.createElementNS('http://www.w3.org/2000/svg', 'text')\n        el.setAttribute('font-size', textSize)\n        el.appendChild(document.createTextNode(textString))\n        this.measurerSvg.appendChild(el)\n        let bbox = el.getBBox()\n        this.measurerSvg.removeChild(el)\n        return { height: bbox.height, width: bbox.width }\n    }\n\n    updateOptions(opts, redraw) {\n        // Some options will update these values\n        let visibleStart, visibleStop\n\n        if ('style' in opts) {\n            this._style = opts['style']\n        }\n        if ('theme' in opts) {\n            this.theme = this.themes[opts['theme'] || 'base']\n        }\n        this.style = Object.assign({}, this.theme['rules'], this._style)\n\n        if ('zoom' in opts) {\n            this.zoom = opts['zoom']\n        }\n        if ('initialDate' in opts) {\n            if (this._viewport) {\n                this._viewport.resetPan()\n            }\n            let centeredDate = utils.toDate(opts.initialDate)\n            this._unpannedVisibleStart = this._leftifyDate(centeredDate)\n            visibleStart = this._unpannedVisibleStart\n            let offsetSeconds = this.visibleWidth * (this.secondsPerDivision / this.style['divisionWidth'])\n            visibleStop = utils.addSeconds(visibleStart, offsetSeconds)\n        }\n        if ('tracker' in opts) {\n            this._tracker = opts['tracker']\n        }\n        if ('nodata' in opts) {\n            this._nodata = !!(opts['nodata'])\n        }\n        if ('wallclock' in opts) {\n            this._wallclock = !!(opts['wallclock'])\n        }\n        if ('data' in opts) {\n            this._data = opts['data']\n        }\n\n        if (!visibleStart) {\n            visibleStart = new Date(this.visibleStart.getTime())\n            visibleStop = new Date(this.visibleStop.getTime())\n        }\n\n        // Make actual load-range a bit wider. We want a comfortable panning\n        // experience without re-rendering or loading data all the time.\n        let timeBetween = 1 * utils.millisBetween(visibleStart, visibleStop)\n        this.loadStart = utils.addMillis(visibleStart, -timeBetween)\n        this.loadStop = utils.addMillis(visibleStop, timeBetween)\n        if (redraw !== false) {\n            // Provide hook to client code to load data in this same range\n            this._fireEvent('loadRange', this.loadStart, this.loadStop)\n            this._doRender() // Explicitly pass start, to ignore any svg pan information\n        }\n        return this\n    }\n\n    setData(data, redraw) {\n        this._data = data\n        if (redraw !== false) {\n            this._doRender()\n        }\n        return this\n    }\n\n    /**\n     * Returns a unique identifier\n     */\n    nextId() {\n        let new_id = 'tlid' + Timeline._nextId\n        Timeline._nextId += 1\n        return new_id\n    }\n\n    on(evt, fn) {\n        if (!(evt in this.eventListeners)) {\n            throw `Unknown event '${evt}'`\n        }\n        this.eventListeners[evt].push(fn)\n        return this\n    }\n\n    off(evt, fn) {\n        if (!(evt in this.eventListeners)) {\n            throw `Unknown event '${evt}'`\n        }\n        this.eventListeners[evt] = this.eventListeners[evt].filter(el => {\n            return el !== fn\n        })\n    }\n\n    _fireEvent(evt, ...args) {\n        this.eventListeners[evt].forEach(l => l(...args))\n    }\n\n    /**\n     * Returns the leftmost user-visible date\n     */\n    get visibleStart() {\n        if (this._viewport) {\n            let xTranslate = this._viewport.xTranslate,\n                secondsBetween = this.secondsPerDivision * (-xTranslate / this.style['divisionWidth'])\n            return utils.addSeconds(this._unpannedVisibleStart, secondsBetween)\n        } else {\n            return this._unpannedVisibleStart\n        }\n    }\n\n    /**\n     * Returns the date in the center of the visible non-sidebar view\n     */\n    get visibleCenter() {\n        let offsetSeconds = (this.visibleWidth / 2) * (this.secondsPerDivision / this.style['divisionWidth'])\n        return utils.addSeconds(this.visibleStart, offsetSeconds)\n    }\n\n    /**\n     * Returns the rightmost user-visible date\n     */\n    get visibleStop() {\n        let offsetSeconds = this.visibleWidth * (this.secondsPerDivision / this.style['divisionWidth'])\n        return utils.addSeconds(this.visibleStart, offsetSeconds)\n    }\n\n    /**\n     * Returns the original visible start (before any panning actions)\n     */\n    get originalVisibleStart() {\n        return this._unpannedVisibleStart\n    }\n\n    get zoom() {\n        return this._zoom\n    }\n\n    /**\n     * Increases or decreases zoom step\n     */\n    set zoom(zoom) {\n        this._zoom = Math.min(Timeline.maxZoom, Math.max(Timeline.minZoom, zoom))\n        this.secondsPerDivision = this._calculateSecondsPerDivision()\n    }\n\n    zoomIn(x) {\n        this.applyZoom(this.zoom + 1, x)\n        return this\n    }\n\n    zoomOut(x) {\n        this.applyZoom(this.zoom - 1, x)\n        return this\n    }\n\n    applyZoom(zoom, x) {\n        if (x === undefined) {\n            let visibleCenter = this.visibleCenter\n            this.zoom = zoom\n            this._viewport.resetPan()\n            this.reveal(visibleCenter)\n        } else {\n            let xDate = this.toDate(x)\n            let xPercent = (x + this.xTranslation) / this.visibleWidth\n\n            // Update secondsPerDivision\n            this.zoom = zoom\n            let newBoxSeconds = this.visibleWidth * (this.secondsPerDivision / this.style['divisionWidth'])\n\n            // Derive date for new visibleCenter (at xPercent 0.5)\n            let offsetSeconds = newBoxSeconds * (0.5 - xPercent)\n            let newCenter = utils.addSeconds(xDate, offsetSeconds)\n\n            this._viewport.resetPan()\n            this.reveal(newCenter)\n        }\n        return this\n    }\n\n    get width() {\n        return this._width\n    }\n\n    /**\n     * Make timeline aware of the available screen space of the client\n     */\n    set width(width) {\n        this._width = width\n    }\n\n    get xTranslation() {\n        if (this._viewport) {\n            return this._viewport.xTranslate\n        } else {\n            return 0\n        }\n    }\n\n    /**\n     * Returns the number of seconds within a divisionWidth for the given\n     * zoom levels. This is not directly exposed to the client, to control\n     * the look of the timescale better.\n     */\n    _calculateSecondsPerDivision() {\n        switch (this._zoom) {\n        case 1:\n            return 1638400\n        case 2:\n            return 819200\n        case 3:\n            return 409600\n        case 4:\n            return 204800\n        case 5:\n            return 102400\n        case 6:\n            return 51200\n        case 7:\n            return 25600\n        case 8:\n            return 12800\n        case 9:\n            return 6400\n        case 10:\n            return 3200\n        case 11:\n            return 1600\n        case 12:\n            return 800\n        case 13:\n            return 400\n        case 14:\n            return 200\n\n        default:\n            throw `Unexpected zoom level ${this._zoom}`\n        }\n    }\n\n    /**\n     * Returns a date matching the provided x offset\n     */\n    toDate(offsetX) {\n        let seconds = (offsetX / this.style['divisionWidth']) * this.secondsPerDivision\n        return utils.addSeconds(this._unpannedVisibleStart, seconds)\n    }\n\n    /**\n     * Returns the x position in svg points for the given date\n     */\n    positionDate(dt) {\n        return this.pointsBetween(this._unpannedVisibleStart, dt) + this.xTranslation\n    }\n\n    /**\n     * Returns the svg point width between two dates\n     */\n    pointsBetween(dt1, dt2) {\n        let td = utils.millisBetween(dt1, dt2) / 1000\n        return (td / this.secondsPerDivision) * this.style['divisionWidth']\n    }\n\n    /**\n     * Register a target that will respond to user interaction\n     */\n    registerInteractionTarget(id, obj, type, el) {\n        this.targetsById[id] = { obj: obj, type: type, el: el }\n    }\n\n    get visibleWidth() {\n        return this.width - this.style['sidebarWidth']\n    }\n\n    /**\n     * Returns a date obtained by converting the specified centered date\n     * to the corresponding leftmost visible date.\n     */\n    _leftifyDate(dt) {\n        let offsetSeconds = - (this.visibleWidth / 2) * (this.secondsPerDivision / this.style['divisionWidth'])\n        return utils.addSeconds(dt, offsetSeconds)\n    }\n\n    render() {\n        this.updateOptions({})\n        return this\n    }\n\n    /**\n     * Reinitializes the viewport and gives all the components the chance\n     * to contribute to the timeline.\n     */\n    _doRender() {\n\n        // Provide the opportunity to clean-up resources if this is a re-rendering\n        if (this._vdom) {\n            for (let contribution of this.contributions) {\n                if (typeof contribution.tearDown === 'function') {\n                    contribution.tearDown()\n                }\n            }\n            this.contributions = []\n        }\n\n        for (let spec of this._data) {\n            this._createContribution(spec)\n        }\n\n        if (this._tracker === 'location') {\n            this._createContribution({ type: 'LocationTracker' })\n        } else if (this._tracker === 'event') {\n            this._createContribution({ type: 'EventTracker' })\n        } else if (this._tracker === 'all') {\n            this._createContribution({ type: 'LocationTracker' })\n            this._createContribution({ type: 'EventTracker' })\n        }\n\n        if (this._nodata) {\n            this._createContribution({ type: 'NoDataZone' })\n        }\n\n        if (this._wallclock) {\n            this._createContribution({ type: 'WallclockLocator' })\n        }\n\n        if (!this._vdom) {\n            this._vdom = new VDom(this, {}, this.style)\n            this._viewport = new Viewport(this)\n            this.containerEl.appendChild(this._vdom.getRootElement())\n        }\n        this._vdom.rebuild(-this._viewport.xTranslate)\n\n        // Provide the opportunity to contributions to initialize\n        for (let contribution of this.contributions) {\n            if (typeof contribution.postRender === 'function') {\n                contribution.postRender(this._vdom.getRootElement())\n            }\n        }\n\n        this._fireEvent('viewportChanged')\n    }\n\n    _createContribution(spec) {\n        let pluginClass = this.plugins[spec['type']]\n        if (!pluginClass) {\n            throw `No plugin could be found matching type '${spec['type']}'`\n        }\n\n        // Contribution-specific style is an ordered merge of:\n        // 1. Timeline-global style (theme-sensitive)\n        // 2. Plugin style (base-rules)\n        // 3. Plugin style (theme-sensitive)\n        // 4. Contribution style\n        let style = Object.assign({}, this.style)\n        if (pluginClass['rules']) {\n            Object.assign(style, pluginClass['rules'])\n            if (pluginClass['rules'][this.theme['type']]) {\n                Object.assign(style, pluginClass['rules'][this.theme['type']])\n            }\n        }\n        if (spec['style']) {\n            Object.assign(style, spec['style'])\n        }\n\n        let contribution = new pluginClass(this, spec /* opts */, style)\n        contribution['type'] = pluginClass['type']\n        this.contributions.push(contribution)\n    }\n\n    notify(eventType, event) {\n        // Detect interaction targets\n        let el = event.target,\n            rootEl = this._vdom.getRootElement()\n\n        while (el && (el !== rootEl) && !el['id']) {\n            el = el.parentNode\n        }\n\n        if (eventType === 'click') {\n            if (this.mouseEnteredTarget) {\n                this._fireEvent('eventClick', {\n                    target: rootEl.getElementById(el['id']),\n                    userObject: this.mouseEnteredTarget['obj'],\n                    type: this.mouseEnteredTarget['type'],\n                })\n            }\n        } else if (eventType === 'mousemove') {\n            if (el && el['id']) {\n                let target = this.targetsById[el['id']]\n                if (target) {\n                    if (target !== this.mouseEnteredTarget) {\n                        if (this.mouseEnteredTarget) {\n                            this._fireEvent('eventMouseLeave', {\n                                target: rootEl.getElementById(el['id']),\n                                userObject: this.mouseEnteredTarget['obj'],\n                                type: this.mouseEnteredTarget['type'],\n                            })\n                        }\n                        this.mouseEnteredTarget = target\n                        this._fireEvent('eventMouseEnter', {\n                            target: rootEl.getElementById(el['id']),\n                            userObject: target['obj'],\n                            type: target['type'],\n                        })\n                    }\n                    this._fireEvent('eventMouseMove', {\n                        target: rootEl.getElementById(el['id']),\n                        userObject: target['obj'],\n                        type: target['type'],\n                    })\n                }\n            } else if (this.mouseEnteredTarget) {\n                this._fireEvent('eventMouseLeave', {\n                    target: rootEl.getElementById(el['id']),\n                    userObject: this.mouseEnteredTarget['obj'],\n                    type: this.mouseEnteredTarget['type'],\n                })\n                this.mouseEnteredTarget = undefined\n            }\n\n            let mouseX = this._viewport.mousePosition(event).x\n            let hoverX = mouseX - this.style['sidebarWidth'] - this._viewport.xTranslate\n            this._fireEvent('hover', {\n                date: this.toDate(hoverX),\n            })\n        } else if (eventType === 'mouseleave') {\n            this._fireEvent('hover', {\n                date: undefined,\n            })\n        } else if (eventType === 'viewportWheel') {\n            // Mouse location x is fixated while zooming\n            let mouseX = this._viewport.mousePosition(event).x\n            let hoverX = mouseX - this.style['sidebarWidth'] - this._viewport.xTranslate\n            if (event.wheelDelta > 0) {\n                this.zoomIn(hoverX)\n            } else if (event.wheelDelta < 0) {\n                this.zoomOut(hoverX)\n            }\n        } else if (eventType === 'panStart') {\n            rootEl.style.cursor = 'move'\n        } else if (eventType === 'panStop') {\n            this._viewport.setInteractionAllowed(false) // Prevent user interaction during async re-render\n            rootEl.style.setProperty('cursor', 'wait', 'important')\n\n            // Force redraw, we may get close to unrendered regions\n            // Async, to allow previous pan to become visible, before reloading\n            // This prevents a movement stutter\n            let that = this\n            setTimeout(() => {\n                that.render()\n                that._viewport.setInteractionAllowed(true)\n                rootEl.style.removeProperty('cursor')\n            }, 50)\n        }\n\n        this._fireEvent(eventType, event)\n    }\n\n    /**\n     * Forwards the viewport by a fraction of the viewport size.\n     */\n    goForward(x = 0.3) {\n        let pos = this.positionDate(this.visibleCenter)\n        this.reveal(this.toDate(pos + (x * (this.visibleWidth))))\n    }\n\n    /**\n     * Reverses the viewport by a fraction of the viewport size.\n     */\n    goBackward(x = 0.3) {\n        let pos = this.positionDate(this.visibleCenter)\n        this.reveal(this.toDate(pos - (x * (this.visibleWidth))))\n    }\n\n    /**\n     * Centers the view on the specified date\n     */\n    reveal(date) {\n        this.updateOptions({\n            initialDate: date,\n        })\n        return this\n    }\n}\n\n/**\n * Statically incrementing id for uniquely identifying something across contributions, or timelines\n */\nTimeline._nextId = 0\n\n\n\n// WEBPACK FOOTER //\n// ./src/Timeline.js","export { default as Band } from './Band'\nexport { default as EventBand } from './EventBand'\nexport { default as EventTracker } from './EventTracker'\nexport { default as LocationTracker } from './LocationTracker'\nexport { default as NoDataZone } from './NoDataZone'\nexport { default as SpacerBand } from './SpacerBand'\nexport { default as Timescale } from './Timescale'\nexport { default as WallclockLocator } from './WallclockLocator'\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/index.js","export { default as AttitudeBand } from './AttitudeBand'\nexport { default as CommsBand } from './CommsBand'\nexport { default as DayNightBand } from './DayNightBand'\nexport { default as DayNightBackgroundAddon } from './DayNightBackgroundAddon'\nexport { default as OrbitNumberBand } from './OrbitNumberBand'\nexport { default as SaaBand } from './SaaBand'\n\n\n\n// WEBPACK FOOTER //\n// ./src/space/index.js","export { default as baseTheme } from './baseTheme'\nexport { default as darkTheme } from './darkTheme'\n\n\n\n// WEBPACK FOOTER //\n// ./src/theme/index.js","import { Defs, G, Rect, Svg } from './tags'\n\n/**\n * Top-level object for a generic (empty) Timeline. The Timeline is split\n * in different types of contributions. Some contributions are fixed, others\n * are timebased (and potentially pannable).\n *\n * An instance of this class is created only once, but dynamic parts of its content\n * are recreated on every new data event. Doing so allows us to install\n * event handlers only once, thereby reducing unresponsiveness between\n * different renderings.\n */\nexport default class VDom {\n\n    constructor(timeline, opts, style) {\n        this.timeline = timeline\n        this.opts = opts\n        this.style = style\n\n        this.rootEl = this.createDomNode(new Svg({\n            width: '100%',\n            height: '100%',\n            style: 'width: 100%; overflow: hidden', // height is set during rebuild()\n        }))\n\n        this.defsEl = this.createDomNode(new Defs({}), this.rootEl)\n        this.filterEls = []\n        this.bandsEl = this.createDomNode(new Svg({ x: this.style['sidebarWidth'], style: 'overflow: visible' }), this.rootEl)\n\n        // vpEl needs to be in a 'g' to make transforms work. So wrap it up\n        let vpSvgWrapperEl = this.createDomNode(new Svg({\n            x: this.style['sidebarWidth'],\n            style: 'overflow: visible',\n        }), this.rootEl)\n\n        this.vpEl = this.createDomNode(new G({ class: 'svg_viewport' }), vpSvgWrapperEl)\n        this.sidebarEl = this.createDomNode(new G(), this.rootEl)\n    }\n\n    getRootElement() {\n        return this.rootEl\n    }\n\n    getViewportElement() {\n        return this.vpEl\n    }\n\n    rebuild(xOffset) {\n        let detachedContent = this.calculateContentModel(xOffset || 0)\n        this.defsEl.innerHTML = ''\n        this.bandsEl.innerHTML = ''\n        this.vpEl.innerHTML = ''\n        this.sidebarEl.innerHTML = ''\n        for (let filterEl of this.filterEls) {\n            this.rootEl.removeChild(filterEl)\n        }\n        this.filterEls = []\n\n        this.createDomNode(detachedContent['defsContent'], this.defsEl)\n        for (let filter of detachedContent['filterContent']) {\n            this.filterEls.push(this.createDomNode(filter, this.rootEl))\n        }\n        this.createDomNode(detachedContent['backgroundContent'], this.bandsEl)\n        this.createDomNode(detachedContent['viewportContent'], this.vpEl)\n        this.createDomNode(detachedContent['sidebarContent'], this.sidebarEl)\n\n        // Adjust fixed elements to new reality\n        // TODO adjust to possible new sidebarWidth as well\n        this.rootEl.style.setProperty('height', this.getTotalHeight() + 'px')\n    }\n\n    /**\n     * Creates detached SVG DOM nodes\n     */\n    calculateContentModel(xOffset) {\n\n        let sidebarContent = [],\n            backgroundContent = [],\n            viewportContent = []\n\n        /**\n         * Draw top-down, to make the shadow effects a bit nicer\n         */\n        let ctx = {\n            x: 0,\n            y: 0,\n            paddingTop: 0,  // Currently used for sidebar to indicate extra lead space inside contribution\n            paddingBottom: 0,  // Currently used for sidebar indicate extra trail space inside contribution\n            total_height: 5 + 5, // 5 for lead, 5 for trail\n            lead: 5, // Forced lead for visual pleasure\n            trail: 5, // Force trail for visual pleasure\n            contributions: this.timeline.contributions,\n            enabledContributions: this.timeline.contributions.filter(el => el.opts.enabled !== false),\n        }\n\n        // Calculate full height, before rendering anything. Some contributions may need this information\n        for (let [i, contribution] of ctx.enabledContributions.entries()) {\n            ctx.total_height += contribution.height\n            if (i !== 0 && contribution.height > 0) {\n                ctx.total_height += this.style['bandDividerHeight']\n            }\n            if (contribution.type === 'SpacerBand') {\n                ctx.total_height += ctx.trail // + ctx.lead;\n            }\n        }\n\n        // Determine the 'first' and the 'last' contribution. But only consider contributions _with_ a sidebar\n        // These contributions' sidebars will receive some extra padding to draw their background.\n        let leadContribution = null,\n            trailContribution = null\n        for (let contribution of ctx.enabledContributions) {\n            if (typeof contribution.renderSidebar === 'function') {\n                if (!leadContribution) {\n                    leadContribution = contribution\n                }\n                trailContribution = contribution\n            }\n        }\n\n        // Draw a generic background for the sidebar, in case an other contribution doesn't (e.g. a SpacerBand)\n        // So that the viewport can still scroll beneath it.\n        let containerBg = window.getComputedStyle(this.timeline.containerEl, null).getPropertyValue('background-color')\n        sidebarContent.push(new Rect({\n            x: ctx.x,\n            y: ctx.y,\n            width: this.style['sidebarWidth'],\n            height: ctx.total_height - ctx.lead,\n            style: `fill: ${containerBg}`,\n        }))\n\n        let doLead = false,\n            doTrail = false\n        for (let [i, contribution] of ctx.enabledContributions.entries()) {\n            // The order here is once again very important.\n            // First the band background, then the viewport so it can pan over it,\n            // and finally the sidebar so that the viewport can pan beneath\n\n            // Check whether the previous or next contribution is a spacer band because this impacts lead/trail too.\n            let afterSpacerBand = i > 0 && ctx.enabledContributions[i - 1].type === 'SpacerBand'\n            let beforeSpacerBand = i < ctx.enabledContributions.length - 1 && ctx.enabledContributions[i + 1].type === 'SpacerBand'\n\n            doLead = (contribution === leadContribution || afterSpacerBand)\n            doTrail = (contribution === trailContribution || beforeSpacerBand)\n\n            if (doLead) {\n                ctx.y += ctx.lead\n            }\n\n            if (typeof contribution.renderBand === 'function') {\n                let els = contribution.renderBand(ctx) || []\n                if (Array.isArray(els)) {\n                    backgroundContent.push(...els)\n                } else {\n                    backgroundContent.push(els)\n                }\n            }\n\n            ctx.x += xOffset\n            if (typeof contribution.renderViewport === 'function') {\n                let els = contribution.renderViewport(ctx) || []\n                if (Array.isArray(els)) {\n                    viewportContent.push(...els)\n                } else {\n                    viewportContent.push(els)\n                }\n            }\n            if (Array.isArray(contribution.opts.addons)) {\n                for (let addon of contribution.opts.addons) {\n                    let els = addon.renderViewportOverlay(ctx, contribution, this.timeline) || []\n                    if (Array.isArray(els)) {\n                        viewportContent.push(...els)\n                    } else {\n                        viewportContent.push(els)\n                    }\n                }\n            }\n            ctx.x -= xOffset\n\n            if (doLead) {\n                ctx.y -= ctx.lead\n                ctx.paddingTop += ctx.lead\n            }\n            if (doTrail) {\n                ctx.paddingBottom += ctx.trail\n            }\n\n            if (typeof contribution.renderSidebar === 'function' && contribution.type !== 'SpacerBand') {\n                let els = contribution.renderSidebar(ctx) || []\n                if (Array.isArray(els)) {\n                    sidebarContent.push(...els)\n                } else {\n                    sidebarContent.push(els)\n                }\n            }\n\n            // Restore paddings\n            if (doLead) {\n                ctx.paddingTop -= ctx.lead\n                ctx.y += 5\n            }\n            if (doTrail) ctx.paddingBottom -= ctx.trail\n\n            let contributionHeight = contribution.height\n            if (contributionHeight > 0) { // Account for border\n                contributionHeight += this.style['bandDividerHeight']\n            }\n            ctx.y += contributionHeight\n        }\n\n        ctx.total_height += ctx.trail\n\n        this.totalHeight = ctx.total_height\n\n        return {\n            defsContent: this.renderDefs(),\n            filterContent: this.renderFilters(),\n            sidebarContent: sidebarContent,\n            backgroundContent: backgroundContent,\n            viewportContent: viewportContent,\n        }\n    }\n\n    getTotalHeight() {\n        return this.totalHeight\n    }\n\n    createDomNode(nodes, appendTo) {\n        let lastEl = undefined\n        if (Array.isArray(nodes)) {\n            for (let node of nodes) {\n                lastEl = this._assembleDomNode(node, appendTo)\n            }\n        } else {\n            lastEl = this._assembleDomNode(nodes, appendTo)\n        }\n        return lastEl\n    }\n\n    _assembleDomNode(node, appendTo) {\n        let newElement\n        if (typeof node === 'object') {\n            newElement = document.createElementNS('http://www.w3.org/2000/svg', node.name)\n            for (let att of Object.keys(node.attributes)) {\n                newElement.setAttribute(att, node.attributes[att])\n            }\n            if (node.children.length !== 0) {\n                this.createDomNode(node.children, newElement)\n            }\n        } else {\n            newElement = document.createTextNode(node)\n        }\n\n        if (appendTo) {\n            appendTo.appendChild(newElement)\n        }\n\n        return newElement\n    }\n\n    renderDefs() {\n        let defs = this.timeline.theme['defs'] || []\n        for (let contribution of this.timeline.contributions) {\n            if (typeof contribution.renderDefs === 'function') {\n                defs.push(contribution.renderDefs() || [])\n            }\n        }\n        return defs\n    }\n\n    renderFilters() {\n        let filters = this.timeline.theme['filters'] || []\n        for (let contribution of this.timeline.contributions) {\n            if (typeof contribution.renderFilters === 'function') {\n                filters.push(contribution.renderFilters() || [])\n            }\n        }\n        return filters\n    }\n}\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/VDom.js","export default class Viewport {\n\n    constructor(timeline) {\n        this.timeline = timeline\n        this.interactionAllowed = true\n        this.mouseDown = false\n        this.panning = false\n        this.panStart = null\n        this.xTranslate = 0\n\n        this.rootEl = timeline._vdom.getRootElement()\n        this.viewportEl = timeline._vdom.getViewportElement()\n\n        /**\n         * Minimum number of points before doing a pan. Helps get rid of minor movements, especially\n         * when just clicking around. Try to keep it low, cause it creates a slight stutter on first\n         * movement.\n         */\n        this.snap = 5\n\n        let viewport = this\n        this.rootEl.addEventListener('click', e => viewport.onClick(e), false)\n        this.rootEl.addEventListener('mouseenter', e => viewport.onMouseEnter(e), false)\n        this.rootEl.addEventListener('mousedown', e => viewport.onMouseDown(e), false)\n        this.rootEl.addEventListener('touchstart', e => viewport.onMouseDown(e), false)\n        this.rootEl.addEventListener('mousemove', e => viewport.onMouseMove(e), false)\n        this.rootEl.addEventListener('touchmove', e => viewport.onMouseMove(e), false)\n        this.rootEl.addEventListener('mouseup', e => viewport.onMouseUp(e), false)\n        this.rootEl.addEventListener('touchend', e => viewport.onMouseUp(e), false)\n        this.rootEl.addEventListener('mouseleave', e => viewport.onMouseLeave(e), false)\n        this.rootEl.addEventListener('touchleave', e => viewport.onMouseLeave(e), false)\n        this.rootEl.addEventListener('touchcancel', e => viewport.onMouseLeave(e), false)\n        this.rootEl.addEventListener('wheel', e => viewport.onWheel(e), false)\n    }\n\n    setInteractionAllowed(interactionAllowed) {\n        this.interactionAllowed = !!interactionAllowed\n    }\n\n    mousePosition(event) {\n        let rect = this.rootEl.getBoundingClientRect()\n        return {\n            x: event.clientX - rect.left,\n            y: event.clientY - rect.top,\n        }\n    }\n\n    onClick(event) {\n        if (!this.interactionAllowed) {\n            return\n        }\n        if (!this.panning) {\n            this.timeline.notify('click', event)\n        }\n    }\n\n    onMouseDown(event) {\n        if (!this.interactionAllowed) {\n            return\n        }\n\n        if (event.button === 0) {\n            this.mouseDown = true\n            this.mouseDown_x = this.mousePosition(event).x\n            this.panStart = this.rootEl.createSVGPoint()\n            this.panStart.x = this.mouseDown_x\n            this.panStart.y = 0\n            this.panStart = this.panStart.matrixTransform(this.viewportEl.getCTM().inverse())\n        }\n\n        event.preventDefault()\n        event.stopPropagation()\n        return false\n    }\n\n    onMouseMove(event) {\n        let dstX = this.mousePosition(event).x\n        if (this.interactionAllowed && this.mouseDown) {\n            if (Math.abs(this.mouseDown_x - dstX) > this.snap) {\n                if (!this.panning) {\n                    this.panning = true\n                    this.timeline.notify('panStart', event)\n                }\n            }\n            if (this.panning) {\n                this._pan(this.panStart.x, dstX)\n            }\n        }\n\n        this.timeline.notify('mousemove', event)\n\n        event.preventDefault()\n        event.stopPropagation()\n        return false\n    }\n\n    onMouseUp(event) {\n        if (!this.interactionAllowed) {\n            return\n        }\n\n        // Ensure new re-rendering aligns with last viewport\n        this.onMouseMove(event)\n\n        if (this.panning) {\n            this.panning = false\n            this.timeline.notify('panStop', event)\n            this.timeline._fireEvent('viewportChanged')\n        }\n        if (this.mouseDown) {\n            this.mouseDown = false\n        }\n\n        event.preventDefault()\n        event.stopPropagation()\n        return false\n    }\n\n    onMouseEnter(event) {\n        this.timeline.notify('mouseenter', event)\n    }\n\n    // Triggers when user moves outside the browser while panning. This does not have an\n    // effect on the SVG anyway, but without this code it would create a stutter when\n    // mouse returns back, because the mouse could be much further than the rendering had\n    // advanced at the point of leaving.\n    onMouseLeave(event) {\n        this.timeline.notify('mouseleave', event)\n        if (this.mouseDown) {\n            if (this.panning) {\n                this.panning = false\n                this.timeline.notify('panStop', event)\n                this.timeline._fireEvent('viewportChanged')\n            }\n            this.mouseDown = false\n            this.timeline.render() // Force redraw, we may get close to unrendered regions\n        }\n    }\n\n    onWheel(event) {\n        this.timeline.notify('viewportWheel', event)\n    }\n\n    /**\n     * Positional pan based on mouse movement\n     */\n    _pan(startX, dstX) {\n        this.xTranslate = dstX - startX - this.timeline.style['sidebarWidth']\n        let transform = this.rootEl.createSVGTransform()\n        transform.setTranslate(this.xTranslate, 0)\n        this.viewportEl.transform.baseVal.initialize(transform)\n        this.timeline._fireEvent('viewportChange')\n    }\n\n    resetPan() {\n        let transform = this.rootEl.createSVGTransform()\n        transform.setTranslate(0, 0)\n        this.viewportEl.transform.baseVal.initialize(transform)\n        this.xTranslate = 0\n    }\n\n    /**\n     * Returns the current x transform\n     */\n    get xTranslate() {\n        return this._xTranslate\n    }\n\n    set xTranslate(val) {\n        this._xTranslate = val\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/Viewport.js","import { ClipPath, G, Path, Rect, Set, Text, Title } from '../tags'\nimport { toDate, isBefore, isAfter } from '../utils'\nimport Band from './Band'\n\n\n/**\n * Basic band for showing events in boxes.\n *\n * Within the band, events are allowed to overlap. An algorithm\n * takes care of spreading it over multiple lines in define-order.\n */\nexport default class EventBand extends Band {\n\n    static get type() {\n        return 'EventBand'\n    }\n\n    static get rules() {\n        return {\n            backgroundColor: '#529bff',\n            backgroundFilter: '',\n            borderColor: '#0a56bc',\n            textColor: '#1c4b8b',\n            cornerRadius: 1,\n            eventLeftMargin: 5,\n            highlightOpacity: 0.7,\n            spaceBetween: 0,\n            wrap: true,\n            lineSpacing: 2,\n            marginTop: 8,\n            marginBottom: 8,\n            eventHeight: 15,\n            dark: {\n                backgroundColor: '#4c4c4c',\n                backgroundFilter: 'url(#darkShadow)',\n                borderColor: '',\n                textColor: '#bbb',\n            },\n        }\n    }\n\n    constructor(timeline, opts, style) {\n        super(timeline, opts, style)\n\n        let events = this.opts.events || []\n        this.interactive = (opts.interactive === true)\n        this.lines = this.spreadAcrossLines(events)\n\n        this.eventHeight = style['eventHeight']\n        this.bandHeight = this.style['marginTop'] + (this.eventHeight * this.lines.length) + (this.style['lineSpacing'] * (this.lines.length - 1)) + this.style['marginBottom']\n\n        // Band could be empty\n        this.bandHeight = Math.max(this.bandHeight, this.style['marginTop'] + this.eventHeight + this.style['marginBottom'])\n    }\n\n    /**\n     * Splits the provided events in different lines so that nothing overlaps within a line.\n     * The calculation converts dates to points, but this is mainly to have the option\n     * of defining a minimum space in points between two line events.\n     */\n    spreadAcrossLines(events) {\n        let lines = []\n        for (let event of events) {\n            let start = toDate(event.start),\n                stop,\n                milestone = event.milestone || !event.stop || (toDate(event.stop).getTime() === start.getTime())\n\n            // Events without duration are considered 'milestones'\n            // Events with duration are only considered 'milestones' when the property is set\n            if (milestone) {\n                stop = (event.stop) ? toDate(event.stop) : start\n            } else {\n                stop = toDate(event.stop)\n            }\n\n            // Only consider if somehow visible within load range\n            if (isBefore(start, this.timeline.loadStop) && isAfter(stop, this.timeline.loadStart)) {\n\n                // Overlap is determined using render width (which may include a label)\n                if (milestone) {\n                    event.renderStartX = this.timeline.positionDate(start) - (this.style['eventHeight'] / 2)\n                    event.renderStopX = event.renderStartX + this.style['eventHeight']\n\n                    let fm = this.timeline.getFontMetrics(event.title, this.style['textSize'])\n                    event.renderStopX += fm['width'] + this.style['eventLeftMargin']\n                    event.textOutside = true\n                } else {\n                    event.renderStartX = this.timeline.positionDate(start)\n                    event.renderStopX = this.timeline.positionDate(stop)\n                    event.offscreenStart = isBefore(start, this.timeline.visibleStart) && isAfter(stop, this.timeline.visibleStart)\n\n                    let title = event.title\n                    if (title && event.offscreenStart) {\n                        title = '' + title\n                    }\n\n                    let fm = this.timeline.getFontMetrics(title, this.style['textSize'])\n\n                    let availableTitleWidth = event.renderStopX - event.renderStartX\n                    if (event.offscreenStart) {\n                        availableTitleWidth = event.renderStopX - this.timeline.positionDate(this.timeline.visibleStart)\n                    }\n\n                    event.textOutside = false\n                    if (this.style['wrap'] && availableTitleWidth < fm['width']) {\n                        event.renderStopX += fm['width'] + this.style['eventLeftMargin']\n                        event.textOutside = true\n                    }\n                }\n\n                let inserted = false,\n                    startX = event.renderStartX,\n                    stopX = event.renderStopX\n                for (let line of lines) {\n                    let min = 0,\n                        max = line.length - 1\n                    while (min <= max) {\n                        let mid = Math.floor((min + max) / 2),\n                            midStartX = line[mid].renderStartX,\n                            midStopX = line[mid].renderStopX\n                        if ((stopX + this.style['spaceBetween']) <= midStartX) {\n                            max = mid - 1 // Put cursor before mid\n                        } else if (startX >= (midStopX + this.style['spaceBetween'])) {\n                            min = mid + 1 // Put cursor after mid\n                        } else {\n                            break // Overlap\n                        }\n                    }\n                    if (min > max) {\n                        line.splice(min, 0, event)\n                        inserted = true\n                        break\n                    }\n                }\n\n                if (!inserted) {\n                    lines.push([ event ]) // A new line\n                }\n            }\n        }\n        return lines\n    }\n\n    get height() {\n        return this.bandHeight\n    }\n\n    renderViewport(ctx) {\n        let g = new G()\n\n        for (let [idx, line] of this.lines.entries()) {\n            let offsetY = ctx.y + this.style['marginTop']\n            offsetY += idx * (this.style['lineSpacing'] + this.eventHeight)\n\n            for (let event of line) {\n                let start = toDate(event.start)\n                let milestone = event.milestone || !event.stop || (toDate(event.stop).getTime() === start.getTime())\n                if (milestone) {\n                    let milestoneG = this.renderMilestone(event, ctx.x, offsetY)\n                    g.addChild(milestoneG)\n                } else {\n                    let eventG = this.renderEvent(event, ctx.x, offsetY)\n                    g.addChild(eventG)\n                }\n            }\n        }\n        return g\n    }\n\n    renderMilestone(milestone, x, y) {\n        let start = toDate(milestone.start),\n            id = this.timeline.nextId()\n\n        let milestoneG = new G({\n            id: id,\n            class: 'event milestone',\n        })\n\n        let rectX = x + this.timeline.positionDate(start),\n            rectY = y,\n            rectWidth = this.eventHeight,\n            rectHeight = this.eventHeight\n\n        // Allow event-specific style overrides\n        let bgColor = milestone.backgroundColor || this.style['backgroundColor'],\n            fgColor = milestone.foregroundColor || this.style['textColor'],\n            borderColor = milestone.borderColor || this.style['borderColor']\n\n        let r = this.eventHeight / 2\n        milestoneG.addChild(new Path({\n            d: `M${rectX},${rectY} l${r},${r} l-${r},${r} l-${r},-${r} l${r},-${r}`,\n            'stroke-width': 1,\n            fill: bgColor,\n            stroke: borderColor,\n            filter: this.style['backgroundFilter'],\n        }))\n\n        let title = milestone.title\n        if (title) {\n            if (milestone.tooltip) {\n                milestoneG.addChild(new Title({}, milestone.tooltip))\n            }\n            let fm = this.timeline.getFontMetrics(title, this.style['textSize'])\n\n            let textX = rectX + rectWidth - (this.eventHeight / 2) + this.style['eventLeftMargin'],\n                textY = rectY + (this.eventHeight / 2)\n\n            // Invisible rect with same width as outside text. Primary use is to catch\n            // mouse interactions over the full rect height, rather than the text height\n            milestoneG.addChild(new Rect({\n                x: textX,\n                y: rectY,\n                width: fm['width'],\n                height: rectHeight,\n                opacity: 0,\n            }))\n\n            milestoneG.addChild(new Text({\n                x: textX,\n                y: textY,\n                fill: fgColor,\n                'pointer-events': 'none',\n                'text-anchor': 'left',\n                'dominant-baseline': 'middle',\n                'font-size': this.style['textSize'],\n            }, title))\n        }\n\n        if (this.interactive) {\n            milestoneG.setAttribute('cursor', this.style['highlightCursor'])\n            milestoneG.addChild(new Set({\n                attributeName: 'opacity',\n                to: this.style['highlightOpacity'],\n                begin: 'mouseover',\n                end: 'mouseout',\n            }))\n            this.timeline.registerInteractionTarget(id, milestone, this.type)\n        }\n\n        return milestoneG\n    }\n\n    renderEvent(event, x, y) {\n        let start = toDate(event.start),\n            stop = toDate(event.stop),\n            id = this.timeline.nextId()\n\n        let eventG = new G({\n            id: id,\n            class: 'event',\n        })\n\n        let rectX = x + this.timeline.positionDate(start),\n            rectY = y,\n            rectWidth = this.timeline.pointsBetween(start, stop),\n            rectHeight = this.eventHeight\n\n        // Allow event-specific style overrides\n        let bgColor = event.backgroundColor || this.style['backgroundColor'],\n            fgColor = event.foregroundColor || this.style['textColor'],\n            borderColor = event.borderColor || this.style['borderColor']\n\n        // Background\n        eventG.addChild(new Rect({\n            x: rectX,\n            y: rectY,\n            width: rectWidth,\n            height: rectHeight,\n            fill: bgColor,\n            stroke: borderColor,\n            rx: this.style['cornerRadius'],\n            filter: this.style['backgroundFilter'],\n        }))\n\n        let title = event.title\n        if (title && event.offscreenStart) {\n            title = '' + title\n        }\n        if (title) {\n            if (event.tooltip) {\n                eventG.addChild(new Title({}, event.tooltip))\n            }\n            let fm = this.timeline.getFontMetrics(title, this.style['textSize'])\n\n            if (event.textOutside) {\n                let textX = rectX + rectWidth + this.style['eventLeftMargin'],\n                    textY = rectY + (this.eventHeight / 2)\n\n                // Invisible rect with same width as outside text. Primary use is to catch\n                // mouse interactions over the full rect height, rather than the text height\n                eventG.addChild(new Rect({\n                    x: textX,\n                    y: rectY,\n                    width: fm['width'],\n                    height: rectHeight,\n                    opacity: 0,\n                }))\n\n                eventG.addChild(new Text({\n                    x: textX,\n                    y: textY,\n                    fill: fgColor,\n                    'pointer-events': 'none',\n                    'text-anchor': 'left',\n                    'dominant-baseline': 'middle',\n                    'font-size': this.style['textSize'],\n                }, title))\n            } else { // Render text inside box\n                // A clipPath for the text, with same dimensions as background\n                let pathId = this.timeline.nextId()\n                eventG.addChild(new ClipPath({ id: pathId }, [\n                    new Rect({\n                        x: rectX,\n                        y: rectY,\n                        width: rectWidth,\n                        height: rectHeight,\n                    }),\n                ]))\n\n                let textX = rectX + this.style['eventLeftMargin']\n\n                // Ensure title is fully visible on screen\n                if (event.offscreenStart) {\n                    textX = Math.max(textX, -this.timeline.xTranslation)\n                }\n\n                // Clipped short name\n                eventG.addChild(new Text({\n                    x: textX,\n                    y: rectY + (this.eventHeight / 2),\n                    fill: fgColor,\n                    'pointer-events': 'none',\n                    'text-anchor': 'left',\n                    'dominant-baseline': 'middle',\n                    'font-size': this.style['textSize'],\n                    'clip-path': `url(#${pathId})`,\n                }, title))\n            }\n        }\n\n        if (this.interactive) {\n            eventG.setAttribute('cursor', this.style['highlightCursor'])\n            eventG.addChild(new Set({\n                attributeName: 'opacity',\n                to: this.style['highlightOpacity'],\n                begin: 'mouseover',\n                end: 'mouseout',\n            }))\n            this.timeline.registerInteractionTarget(id, event, this.type)\n        }\n\n        return eventG\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/EventBand.js","import { G, Line, Rect } from '../tags'\nimport { toDate } from '../utils'\n\n/**\n * Highlights active events, based on mouse position\n */\nexport default class EventTracker {\n\n    static get type() {\n        return 'EventTracker'\n    }\n\n    static get rules() {\n        return {\n            backgroundColor: 'lightgrey',\n            backgroundOpacity: 0.2,\n            lineColor: 'black',\n            lineOpacity: 0.4,\n            dark: {\n                backgroundColor: 'grey',\n            },\n        }\n    }\n\n    constructor(timeline, opts, style) {\n        this.timeline = timeline\n        this.opts = opts\n        this.style = style\n\n        this.trackerId = timeline.nextId()\n        this.rectId = timeline.nextId()\n        this.lineLeftId = timeline.nextId()\n        this.lineRightId = timeline.nextId()\n    }\n\n    get height() {\n        return 0\n    }\n\n    renderViewport(ctx) {\n        return new G({\n            id: this.trackerId,\n            style: 'visibility: hidden',\n        }, [ new Rect({\n            id: this.rectId,\n            x: ctx.x,\n            y: ctx.lead,\n            width: 0,\n            height: ctx.total_height - ctx.trail,\n            fill: this.style['backgroundColor'],\n            'fill-opacity': this.style['backgroundOpacity'],\n            'pointer-events': 'none',\n        }), new Line({\n            id: this.lineLeftId,\n            x1: ctx.x,\n            y1: ctx.lead,\n            x2: 0,\n            y2: ctx.total_height - ctx.trail,\n            stroke: this.style['lineColor'],\n            'stroke-dasharray': '4 3',\n            'stroke-opacity': this.style['lineOpacity'],\n        }), new Line({\n            id: this.lineRightId,\n            x1: ctx.x,\n            y1: ctx.lead,\n            x2: 0,\n            y2: ctx.total_height - ctx.trail,\n            stroke: this.style['lineColor'],\n            'stroke-opacity': this.style['lineOpacity'],\n            'stroke-dasharray': '4 3',\n        })])\n    }\n\n    postRender(svgEl) {\n        let trackerEl = svgEl.getElementById(this.trackerId),\n            rectEl = svgEl.getElementById(this.rectId),\n            lineLeftEl = svgEl.getElementById(this.lineLeftId),\n            lineRightEl = svgEl.getElementById(this.lineRightId),\n            timeline = this.timeline\n\n        this.eventMouseEnterListener = function (obj) {\n            if (obj && obj.userObject && obj.userObject['start'] && obj.userObject['stop']) {\n                let x1 = timeline.positionDate(toDate(obj.userObject['start'])),\n                    x2 = timeline.positionDate(toDate(obj.userObject['stop']))\n\n                rectEl.setAttribute('x', x1)\n                rectEl.setAttribute('width', x2 - x1)\n\n                lineLeftEl.setAttribute('x1', x1)\n                lineLeftEl.setAttribute('x2', x1)\n\n                lineRightEl.setAttribute('x1', x2)\n                lineRightEl.setAttribute('x2', x2)\n\n                trackerEl.style.visibility = 'visible'\n            }\n        }\n\n        this.eventMouseLeaveListener = function () {\n            if (rectEl) {\n                trackerEl.style.visibility = 'hidden'\n            }\n        }\n\n        timeline.on('eventMouseEnter', this.eventMouseEnterListener)\n        timeline.on('eventMouseLeave', this.eventMouseLeaveListener)\n    }\n\n    tearDown() {\n        this.timeline.off('eventMouseEnter', this.eventMouseEnterListener)\n        this.timeline.off('eventMouseLeave', this.eventMouseLeaveListener)\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/EventTracker.js","import { G, Ellipse, Line, RadialGradient, Stop } from '../tags'\n\n/**\n * Mouse tracker for non-mobile devices.\n */\nexport default class LocationTracker {\n\n    static get type() {\n        return 'LocationTracker'\n    }\n\n    static get rules() {\n        return {\n            knobColor: '#ccc',\n            knobRadius: 3,\n            lineColor: '#ccc',\n            lineWidth: '1px',\n            lineOpacity: 0.6,\n            dark: {\n                lineColor: 'grey',\n            },\n        }\n    }\n\n    constructor(timeline, opts, style) {\n        this.timeline = timeline\n        this.opts = opts\n        this.style = style\n\n        this.knobGradientId = timeline.nextId()\n        this.trackerId = timeline.nextId()\n    }\n\n    get height() {\n        return 0\n    }\n\n    renderDefs() {\n        return new RadialGradient({\n            id: this.knobGradientId, cx: '50%', cy: '50%', r: '50%', fx: '25%', fy: '25%',\n        }, [\n            new Stop({\n                offset: '0%',\n                'stop-color': '#fff',\n                'stop-opacity': 1,\n            }),\n            new Stop({\n                offset: '100%',\n                'stop-color': this.style['knobColor'],\n                'stop-opacity': 1,\n            }),\n        ])\n    }\n\n    renderViewport(ctx) {\n        return new G({\n            id: this.trackerId,\n            style: 'visibility: hidden',\n        }, [\n            new Line({\n                x1: ctx.x - this.style['knobRadius'],\n                y1: ctx.lead + this.style['knobRadius'],\n                x2: 0,\n                y2: ctx.total_height - ctx.trail - this.style['knobRadius'],\n                stroke: this.style['lineColor'],\n                'stroke-width': this.style['lineWidth'],\n                'stroke-opacity': this.style['lineOpacity'],\n                'stroke-dasharray': '4 3',\n                'pointer-events': 'none',\n            }),\n            new Ellipse({\n                cx: ctx.x - this.style['knobRadius'],\n                cy: ctx.lead,\n                rx: this.style['knobRadius'],\n                ry: this.style['knobRadius'],\n                fill: `url(#${this.knobGradientId})`,\n            }),\n            new Ellipse({\n                cx: ctx.x - this.style['knobRadius'],\n                cy: ctx.total_height - ctx.trail,\n                rx: this.style['knobRadius'],\n                ry: this.style['knobRadius'],\n                fill: `url(#${this.knobGradientId})`,\n            }),\n        ])\n    }\n\n    postRender(svgEl) {\n        let locationTrackerEl = svgEl.getElementById(this.trackerId),\n            timeline = this.timeline,\n            style = this.style\n\n        this.mouseMoveListener = function (event) {\n            if (locationTrackerEl) {\n                let dstX = timeline._viewport.mousePosition(event).x,\n                    newTrackerX = dstX - style['sidebarWidth'] - timeline._viewport.xTranslate\n                locationTrackerEl.childNodes[0].setAttribute('x1', newTrackerX)\n                locationTrackerEl.childNodes[0].setAttribute('x2', newTrackerX)\n                locationTrackerEl.childNodes[1].setAttribute('cx', newTrackerX)\n                locationTrackerEl.childNodes[2].setAttribute('cx', newTrackerX)\n            }\n        }\n\n        this.mouseEnterListener = function () {\n            if (locationTrackerEl) {\n                locationTrackerEl.style.visibility = 'visible'\n            }\n        }\n\n        this.mouseLeaveListener = function () {\n            if (locationTrackerEl) {\n                locationTrackerEl.style.visibility = 'hidden'\n            }\n        }\n\n        this.timeline.on('mousemove', this.mouseMoveListener)\n        this.timeline.on('mouseenter', this.mouseEnterListener)\n        this.timeline.on('mouseleave', this.mouseLeaveListener)\n    }\n\n    tearDown() {\n        this.timeline.off('mousemove', this.mouseMoveListener)\n        this.timeline.off('mouseenter', this.mouseEnterListener)\n        this.timeline.off('mouseleave', this.mouseLeaveListener)\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/LocationTracker.js","import { G, Rect } from '../tags'\n\n/**\n * Highlights the horizontal time ranges where no data is available.\n * Only non-spacer bands are covered, to increase the look near the sidebar\n */\nexport default class NoDataZone {\n\n    static get type() {\n        return 'NoDataZone'\n    }\n\n    static get rules() {\n        return {\n            backgroundColor: '#fff',\n            backgroundFilter: 'crossHatch',\n            dark: {\n                backgroundColor: '#2b2b2b',\n                backgroundFilter: 'darkHatch',\n            },\n        }\n    }\n\n    constructor(timeline, opts, style) {\n        this.timeline = timeline\n        this.opts = opts\n        this.style = style\n    }\n\n    get height() {\n        return 0\n    }\n\n    renderViewport(ctx) {\n        let g = new G(),\n            zone_y = ctx.lead,\n            zoneHeight = 0\n        for (let [i, contribution] of ctx.enabledContributions.entries()) {\n            let contributionHeight = contribution.height + this.style['bandDividerHeight']\n            if (i === ctx.enabledContributions.length - 1) {\n                zoneHeight += contributionHeight\n            }\n            if (contribution.type === 'SpacerBand' || i === ctx.enabledContributions.length - 1) {\n                g.addChild(new Rect({\n                    x: ctx.x + this.timeline.positionDate(this.timeline.loadStop),\n                    y: zone_y,\n                    width: 15000,\n                    height: zoneHeight,\n                    fill: this.style['backgroundColor'],\n                    'pointer-events': 'none',\n                }))\n                g.addChild(new Rect({\n                    x: ctx.x + this.timeline.positionDate(this.timeline.loadStop),\n                    y: zone_y,\n                    width: 15000,\n                    height: zoneHeight,\n                    fill: `url(#${this.style['backgroundFilter']})`,\n                    'pointer-events': 'none',\n                }))\n                g.addChild(new Rect({\n                    x: ctx.x + this.timeline.positionDate(this.timeline.loadStart) - 15000,\n                    y: zone_y,\n                    width: 15000,\n                    height: zoneHeight,\n                    fill: this.style['backgroundColor'],\n                    'pointer-events': 'none',\n                }))\n                g.addChild(new Rect({\n                    x: ctx.x + this.timeline.positionDate(this.timeline.loadStart) - 15000,\n                    y: zone_y,\n                    width: 15000,\n                    height: zoneHeight,\n                    fill: `url(#${this.style['backgroundFilter']})`,\n                    'pointer-events': 'none',\n                }))\n                zone_y += zoneHeight + contributionHeight + ctx.lead\n                zoneHeight = 0\n            } else {\n                zoneHeight += contributionHeight\n            }\n        }\n\n        return g\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/NoDataZone.js","import { Rect } from '../tags'\nimport Band from './Band'\n\n/**\n * Separator 'band' that can be added to a timeline configuration to add space between the surrounding bands.\n * Interpreted by timeline.\n */\nexport default class SpacerBand extends Band {\n\n    static get type() {\n        return 'SpacerBand'\n    }\n\n    constructor(timeline, opts, style) {\n        super(timeline, opts, style)\n    }\n\n    renderBand() {\n        return []\n    }\n\n    renderSidebar(ctx) {\n        return new Rect({\n            x: ctx.x,\n            y: ctx.y,\n            width: this.style['sidebarWidth'],\n            height: this.height + ctx.paddingTop + ctx.paddingBottom,\n            cursor: 'default',\n            fill: this.style['sidebarBackgroundColor'],\n            filter: this.style['sidebarBackgroundFilter'],\n        })\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/SpacerBand.js","import { Defs, Line, Pattern, Rect, Svg, Text } from '../tags'\nimport * as utils from '../utils'\nimport Band from './Band'\n\n\nlet SCALE_1H = 1,\n    SCALE_QD = 2,\n    SCALE_1D = 3,\n    SCALE_5D = 4,\n    SCALE_1M = 5\n\n/**\n * TIMESCALE\n *\n * For deeper zooms we should draw inspiration from video editing software\n * where they just show sth like HH:mm:ss at rounded locations, and then\n * with vertical dividers to make it more explicit\n */\nexport default class Timescale extends Band {\n\n    static get type() {\n        return 'Timescale'\n    }\n\n    static get rules() {\n        return {\n            textColor: 'grey',\n            majorTickColor: '#aaa',\n            majorTickWidth: 1,\n            minorTickColor: '#aaa',\n            minorTickWidth: 1,\n            midTickColor: '#aaa',\n            midTickWidth: 1,\n            adjust: true,\n            dark: {\n                horizontalTickLineColor: '#333',\n                horizontalTickLineWidth: 2,\n            },\n        }\n    }\n\n    constructor(timeline, opts, style) {\n        super(timeline, opts, style)\n\n        if (!opts.resolution || opts.resolution === 'auto') {\n            if (this._testSpread(60 * 60 * 1000)) {\n                this.scale = SCALE_1H\n            } else if (this._testSpread(6 * 60 * 60 * 1000)) {\n                this.scale = SCALE_QD\n            } else if (this._testSpread(24 * 60 * 60 * 1000)) {\n                this.scale = SCALE_1D\n            } else if (this._testSpread(5 * 24 * 60 * 60 * 1000)) {\n                this.scale = SCALE_5D\n            } else {\n                this.scale = SCALE_1M\n            }\n        } else {\n            // TODO\n        }\n\n        this.dayFormat = this.opts.dayFormat || 'DDDD'\n        this.contributionId = timeline.nextId()\n    }\n\n    /**\n     * The important thing here is that ticks are drawn using SVG patterns. This makes\n     * it lighter in terms of DOM Size. However, we need to do some tricks to correctly\n     * align them with the rest of the scale.\n     */\n    renderViewport(ctx) {\n        // visibleStart might not be exactly aligned on the hour, so offset our pattern\n        // TODO i think we need to account for an offset between visibleStart and loadStart here\n        // TODO because the rect (the hour) begins at loadStart. Not visibleStart.\n        let startOfHour = utils.startOfHour(this.timeline.visibleStart),\n            offsetX = this.timeline.pointsBetween(this.timeline.visibleStart, startOfHour)\n\n        let tickSvg = new Svg({\n            x: ctx.x + offsetX,\n            y: ctx.y,\n            height: this.style['bandHeight'],\n            style: 'overflow: visible',\n        }, new Defs({}, [\n            this._renderHourPattern(),\n        ]))\n\n        let scaleBg = {\n            x: this.timeline.positionDate(this.timeline.loadStart),\n            y: 0,\n            width: this.timeline.pointsBetween(this.timeline.loadStart, this.timeline.loadStop) - offsetX,\n            height: this.style['bandHeight'],\n            fill: this.style['bandBackgroundColor'],\n        }\n\n        if (this.style['horizontalTickLineColor']) {\n            scaleBg['stroke'] = this.style['horizontalTickLineColor']\n        }\n        if (this.style['horizontalTickLineWidth']) {\n            scaleBg['stroke-width'] = this.style['horizontalTickLineWidth']\n        }\n\n        tickSvg.addChild(new Rect(scaleBg))\n\n        let labelSvg = new Svg({\n            x: ctx.x,\n            y: ctx.y,\n            height: this.style['bandHeight'],\n            style: 'overflow: visible',\n        })\n        if (this.scale === SCALE_1H) {\n            scaleBg['fill'] = `url(#${this.contributionId}_1h)`,\n            labelSvg.addChild(this._renderHoursScale(this.opts.tz))\n        } else if (this.scale === SCALE_QD) {\n            labelSvg.addChild(this._renderQuarterDaysScale(this.opts.tz))\n        } else if (this.scale === SCALE_1D) {\n            labelSvg.addChild(this._renderWeekDaysScale(this.opts.tz))\n        } else if (this.scale === SCALE_5D) {\n            labelSvg.addChild(this._renderWeeksScale(this.opts.tz))\n        } else {\n            labelSvg.addChild(this._renderMonthsScale(this.opts.tz))\n        }\n\n        return [tickSvg, labelSvg]\n    }\n\n    /**\n     * Estimates if the specified step (in milliseconds) gives a\n     * visually pleasing spread when rendering all steps\n     */\n    _testSpread(step) {\n        let startX = this.timeline.positionDate(this.timeline.loadStart),\n            testDate = utils.addMillis(this.timeline.loadStart, step),\n            x = this.timeline.positionDate(testDate),\n            xDiff = x - startX\n        return (xDiff > this.timeline.style['divisionWidth'] * 2)\n    }\n\n    _renderHourPattern() {\n        // Make the pattern the same size as one hour\n        let width = this.style['divisionWidth'] * (60 * 60 / this.timeline.secondsPerDivision),\n            height = this.style['bandHeight']\n\n        // it might be that we need to offset due to the visible start\n        // position not aligning exactly on the hour. However, we do this\n        // offsetting not here, but on the parent svg, because otherwise SVG\n        // does some weird rounding shenanigans which makes our ticks disappear.\n        return new Pattern({\n            id: this.contributionId + '_1h',\n            x: 0,\n            y: 0,\n            width: width,\n            height: height,\n            patternUnits: 'userSpaceOnUse',\n        }, [\n            new Line({\n                x1: 0, y1: 0,\n                x2: 0, y2: height,\n                stroke: this.style['majorTickColor'],\n                'stroke-width': this.style['majorTickWidth'],\n            }),\n            new Line({\n                x1: width * 0.25, y1: height * 0.8,\n                x2: width * 0.25, y2: height,\n                stroke: this.style['minorTickColor'],\n                'stroke-width': this.style['minorTickWidth'],\n            }),\n            new Line({\n                x1: width * 0.5, y1: height * 0.6,\n                x2: width * 0.5, y2: height,\n                stroke: this.style['midTickColor'],\n                'stroke-width': this.style['midTickWidth'],\n            }),\n            new Line({\n                x1: width * 0.75, y1: height * 0.8,\n                x2: width * 0.75, y2: height,\n                stroke: this.style['minorTickColor'],\n                'stroke-width': this.style['minorTickWidth'],\n            }),\n        ])\n    }\n\n    _renderHoursScale(tz) {\n        let result = []\n\n        // Trunc it to hours before positioning\n        let date = utils.startOfHour(this.timeline.loadStart)\n\n        while (date.getTime() <= this.timeline.loadStop.getTime()) {\n            let x = this.timeline.positionDate(date)\n            let label = utils.formatDate(date, 'HH', tz)\n            if (label === '00') {\n                result.push(new Text({\n                    x: x + 2,\n                    y: this.style['bandHeight'] / 4,\n                    cursor: 'default',\n                    fill: this.style['textColor'],\n                    'font-size': this.style['textSize'],\n                    'text-anchor': 'left',\n                    'dominant-baseline': 'middle',\n                }, utils.formatDate(date, 'MMM', tz) + ' ' + utils.formatDate(date, 'DD', tz)))\n                result.push(new Text({\n                    x: x + 2,\n                    y: this.style['bandHeight'] * 0.75,\n                    cursor: 'default',\n                    fill: this.style['textColor'],\n                    'font-size': this.style['textSize'],\n                    'text-anchor': 'left',\n                    'dominant-baseline': 'middle',\n                }, label))\n            } else {\n                result.push(new Text({\n                    x: x + 2,\n                    y: this.style['bandHeight'] / 2,\n                    cursor: 'default',\n                    fill: this.style['textColor'],\n                    'font-size': this.style['textSize'],\n                    'text-anchor': 'left',\n                    'dominant-baseline': 'middle',\n                }, label))\n            }\n            date.setTime(date.getTime() + (60 * 60 * 1000))\n        }\n\n        return result\n    }\n\n    _renderQuarterDaysScale(tz) {\n        let result = []\n        let date = utils.startOfDay(this.timeline.loadStart, tz)\n\n        while (date.getTime() <= this.timeline.loadStop.getTime()) {\n            let x = this.timeline.positionDate(date)\n            let label = utils.formatDate(date, 'HH', tz)\n            if (label === '00') {\n                result.push(new Line({\n                    x1: x, y1: 0,\n                    x2: x, y2: this.style['bandHeight'],\n                    stroke: this.style['majorTickColor'],\n                    'stroke-width': this.style['majorTickWidth'],\n                }))\n                result.push(new Text({\n                    x: x + 2,\n                    y: this.style['bandHeight'] / 4,\n                    cursor: 'default',\n                    fill: this.style['textColor'],\n                    'font-size': this.style['textSize'],\n                    'text-anchor': 'left',\n                    'dominant-baseline': 'middle',\n                }, utils.formatDate(date, 'ddd', tz) + ' ' + utils.formatDate(date, 'DD', tz) + '/' + utils.formatDate(date, 'MM', tz)))\n            } else {\n                result.push(new Line({\n                    x1: x, y1: this.style['bandHeight'] / 2,\n                    x2: x, y2: this.style['bandHeight'],\n                    stroke: this.style['majorTickColor'],\n                    'stroke-width': this.style['majorTickWidth'],\n                }))\n            }\n\n            if (tz === 'GMT' || tz === 'UTC') {\n                // Force full duration of 6 hours\n                date.setTime(date.getTime() + (6 * 60 * 60 * 1000))\n            } else {\n                // Add 'about' 6 hours, depending on DST transition (e.g. CET/CEST)\n                // This to prevent labels changing to 01, 07, 13, ... instead of 00, 06, 12\n                date.setHours(date.getHours() + 6)\n            }\n\n            let x2 = this.timeline.positionDate(date)\n            result.push(new Text({\n                x: ((x + x2) / 2) + 2,\n                y: this.style['bandHeight'] * 0.75,\n                cursor: 'default',\n                fill: this.style['textColor'],\n                'font-size': this.style['textSize'],\n                'text-anchor': 'middle',\n                'dominant-baseline': 'middle',\n            }, label))\n        }\n\n        return result\n    }\n\n    _renderDaysScale(tz) {\n        let result = []\n\n        // Trunc to a day start before positioning\n        let date = utils.startOfDay(this.timeline.loadStart, tz)\n\n        while (date.getTime() <= this.timeline.loadStop.getTime()) {\n            let x = this.timeline.positionDate(date)\n            result.push(new Line({\n                x1: x, y1: 0,\n                x2: x, y2: this.style['bandHeight'],\n                stroke: this.style['majorTickColor'],\n                'stroke-width': this.style['majorTickWidth'],\n            }))\n            let label = utils.formatDate(date, 'Do', tz)\n            if (label === '01') {\n                result.push(new Text({\n                    x: x + 2,\n                    y: this.style['bandHeight'] / 4,\n                    cursor: 'default',\n                    fill: this.style['textColor'],\n                    'font-size': this.style['textSize'],\n                    'text-anchor': 'left',\n                    'dominant-baseline': 'middle',\n                }, utils.formatDate(date, 'MMM', tz)))\n                result.push(new Text({\n                    x: x + 2,\n                    y: this.style['bandHeight'] * 0.75,\n                    cursor: 'default',\n                    fill: this.style['textColor'],\n                    'font-size': this.style['textSize'],\n                    'text-anchor': 'left',\n                    'dominant-baseline': 'middle',\n                }, label))\n            } else {\n                result.push(new Text({\n                    x: x + 2,\n                    y: this.style['bandHeight'] / 2,\n                    cursor: 'default',\n                    fill: this.style['textColor'],\n                    'font-size': this.style['textSize'],\n                    'text-anchor': 'left',\n                    'dominant-baseline': 'middle',\n                }, label))\n            }\n\n            if (tz === 'GMT' || tz === 'UTC') {\n                // Force full duration of 24 hours\n                date.setTime(date.getTime() + (24 * 60 * 60 * 1000))\n            } else {\n                // Add 'about' 24 hours, depending on DST transition (e.g. CET/CEST)\n                date.setHours(date.getHours() + 24)\n            }\n        }\n\n        return result\n    }\n\n    /*\n     * Tier 1: Months\n     * Tier 2: Week start day\n     */\n    _renderWeeksScale(tz) {\n        let result = []\n\n        // Render months\n        let date = utils.startOfMonth(this.timeline.loadStart, tz)\n        while (date.getTime() <= this.timeline.loadStop.getTime()) {\n            let x = this.timeline.positionDate(date)\n            result.push(new Line({\n                x1: x, y1: 0,\n                x2: x, y2: this.style['bandHeight'] / 2,\n                stroke: this.style['majorTickColor'],\n                'stroke-width': this.style['majorTickWidth'],\n            }))\n            result.push(new Text({\n                x: x + 2,\n                y: this.style['bandHeight'] / 4,\n                cursor: 'default',\n                fill: this.style['textColor'],\n                'font-size': this.style['textSize'],\n                'text-anchor': 'left',\n                'dominant-baseline': 'middle',\n            }, utils.formatDate(date, 'MMMM', tz)))\n\n            if (tz === 'GMT' || tz === 'UTC') {\n                date.setUTCMonth(date.getUTCMonth() + 1, 1)\n            } else {\n                date.setMonth(date.getMonth() + 1, 1)\n            }\n        }\n\n        // Render week starts\n        date = utils.startOfWeek(this.timeline.loadStart, tz)\n        while (date.getTime() <= this.timeline.loadStop.getTime()) {\n            let x = this.timeline.positionDate(date)\n            let label = utils.formatDate(date, 'DD', tz) + '/' + utils.formatDate(date, 'MM', tz)\n            result.push(new Line({\n                x1: x, y1: this.style['bandHeight'] / 2,\n                x2: x, y2: this.style['bandHeight'],\n                stroke: this.style['majorTickColor'],\n                'stroke-width': this.style['majorTickWidth'],\n            }))\n\n            // Calculate date for next iteration\n            if (tz === 'GMT' || tz === 'UTC') {\n                date.setUTCDate(date.getUTCDate() + 7)\n            } else {\n                date.setDate(date.getDate() + 7)\n            }\n\n            let x2 = this.timeline.positionDate(date)\n            result.push(new Text({\n                x: ((x + x2) / 2) + 2,\n                y: this.style['bandHeight'] * 0.75,\n                cursor: 'default',\n                fill: this.style['textColor'],\n                'font-size': this.style['textSize'],\n                'text-anchor': 'middle',\n                'dominant-baseline': 'middle',\n            }, label))\n        }\n\n        return result\n    }\n\n    _renderWeekDaysScale(tz) {\n        let result = []\n\n        // Trunc to a day start before positioning\n        let date = utils.startOfWeek(this.timeline.loadStart, tz)\n\n        while (date.getTime() <= this.timeline.loadStop.getTime()) {\n            let weekDay, shortYear\n            if (tz === 'GMT' || tz === 'UTC') {\n                weekDay = date.getUTCDay()\n                shortYear = date.getUTCFullYear() % 100\n            } else {\n                weekDay = date.getDay()\n                shortYear = date.getFullYear() % 100\n            }\n            let x = this.timeline.positionDate(date)\n            if (weekDay === 1) { // Monday\n                result.push(new Line({\n                    x1: x, y1: 0,\n                    x2: x, y2: this.style['bandHeight'],\n                    stroke: this.style['majorTickColor'],\n                    'stroke-width': this.style['majorTickWidth'],\n                }))\n                result.push(new Text({\n                    x: x + 2,\n                    y: this.style['bandHeight'] / 4,\n                    cursor: 'default',\n                    fill: this.style['textColor'],\n                    'font-size': this.style['textSize'],\n                    'text-anchor': 'left',\n                    'dominant-baseline': 'middle',\n                }, utils.formatDate(date, 'DD', tz) + ' ' + utils.formatDate(date, 'MMM', tz) + ', \\'' + shortYear))\n            } else {\n                result.push(new Line({\n                    x1: x, y1: this.style['bandHeight'] / 2,\n                    x2: x, y2: this.style['bandHeight'],\n                    stroke: this.style['majorTickColor'],\n                    'stroke-width': this.style['majorTickWidth'],\n                }))\n            }\n            let textLabel = utils.formatDate(date, 'dd', tz).charAt(0)\n\n            // Calculate date for next iteration\n            if (tz === 'GMT' || tz === 'UTC') {\n                // Force full duration of 24 hours\n                date.setTime(date.getTime() + (24 * 60 * 60 * 1000))\n            } else {\n                // Add 'about' 24 hours, depending on DST transition (e.g. CET/CEST)\n                date.setHours(date.getHours() + 24)\n            }\n\n            let x2 = this.timeline.positionDate(date)\n            result.push(new Text({\n                x: x + ((x2 - x) / 2),\n                y: this.style['bandHeight'] * 0.75,\n                cursor: 'default',\n                fill: this.style['textColor'],\n                'font-size': this.style['textSize'],\n                'text-anchor': 'middle',\n                'dominant-baseline': 'middle',\n            }, textLabel))\n        }\n\n        return result\n    }\n\n    _renderMonthsScale(tz) {\n        let result = []\n\n        // Trunc to a month start before positioning\n        let date = utils.startOfYear(this.timeline.loadStart, tz)\n\n        while (date.getTime() <= this.timeline.loadStop.getTime()) {\n            let x = this.timeline.positionDate(date)\n            let label = utils.formatDate(date, 'MMM', tz)\n            if (label === 'Jan') {\n                result.push(new Line({\n                    x1: x, y1: 0,\n                    x2: x, y2: this.style['bandHeight'],\n                    stroke: this.style['majorTickColor'],\n                    'stroke-width': this.style['majorTickWidth'],\n                }))\n                result.push(new Text({\n                    x: x + 2,\n                    y: this.style['bandHeight'] / 4,\n                    cursor: 'default',\n                    fill: this.style['textColor'],\n                    'font-size': this.style['textSize'],\n                    'text-anchor': 'left',\n                    'dominant-baseline': 'middle',\n                }, utils.formatDate(date, 'YYYY', tz)))\n            } else {\n                result.push(new Line({\n                    x1: x, y1: this.style['bandHeight'] / 2,\n                    x2: x, y2: this.style['bandHeight'],\n                    stroke: this.style['majorTickColor'],\n                    'stroke-width': this.style['majorTickWidth'],\n                }))\n            }\n\n            if (tz === 'GMT' || tz === 'UTC') {\n                date.setUTCMonth(date.getUTCMonth() + 1, 1)\n            } else {\n                date.setMonth(date.getMonth() + 1, 1)\n            }\n\n            let x2 = this.timeline.positionDate(date)\n            result.push(new Text({\n                x: ((x + x2) / 2) + 2,\n                y: this.style['bandHeight'] * 0.75,\n                cursor: 'default',\n                fill: this.style['textColor'],\n                'font-size': this.style['textSize'],\n                'text-anchor': 'middle',\n                'dominant-baseline': 'middle',\n            }, label))\n        }\n\n        return result\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/Timescale.js","import { Ellipse, G, Line, RadialGradient, Rect, Stop } from '../tags'\n\nclass LocalTimeProvider {\n\n    constructor(locator) {\n        this._intervalId = setInterval(() => {\n            locator.updateTime(new Date())\n        }, 500)\n    }\n\n    stop() {\n        clearInterval(this._intervalId)\n    }\n}\n\n/**\n * Vertical Time Locator\n */\nexport default class WallclockLocator {\n\n    static get type() {\n        return 'WallclockLocator'\n    }\n\n    static get rules() {\n        return {\n            knobColor: 'red',\n            knobRadius: 3,\n            lineColor: 'red',\n            lineWidth: '1px',\n            lineOpacity: 0.6,\n            pastBackgroundColor: 'lightgrey',\n            pastBackgroundOpacity: 0.4,\n        }\n    }\n\n    constructor(timeline, opts, style) {\n        this.timeline = timeline\n        this.opts = opts\n        this.style = style\n\n        this.locatorKnobGradientId = timeline.nextId()\n        this.time = opts.time || new Date()\n        this.clockUpdater = undefined\n    }\n\n    get height() {\n        return 0\n    }\n\n    updateTime(newTime) {\n        this.time = newTime\n        if (this.wallclockLocatorLineEl) {\n            let xString = this.timeline.pointsBetween(this.timeline._unpannedVisibleStart, newTime)\n            this.wallclockLocatorLineEl.childNodes[0].setAttribute('x1', xString)\n            this.wallclockLocatorLineEl.childNodes[0].setAttribute('x2', xString)\n            this.wallclockLocatorLineEl.childNodes[1].setAttribute('cx', xString)\n            this.wallclockLocatorLineEl.childNodes[2].setAttribute('cx', xString)\n        }\n\n        if (this.wallclockLocatorPastEl) {\n            // For past-overlay, just adjust width\n            let pointsBetween = this.timeline.pointsBetween(this.timeline.loadStart, newTime)\n            let xString = String(Math.max(pointsBetween, 0))\n            for (let node of this.wallclockLocatorPastEl.childNodes) {\n                node.setAttribute('width', xString)\n            }\n        }\n    }\n\n    renderDefs() {\n        return new RadialGradient({\n            id: this.locatorKnobGradientId,\n            cx: '50%',\n            cy: '50%',\n            r: '50%',\n            fx: '25%',\n            fy: '25%',\n        }, [\n            new Stop({\n                offset: '0%',\n                'stop-color': '#fff',\n                'stop-opacity': 1,\n            }),\n            new Stop({\n                offset: '100%',\n                'stop-color': this.style['knobColor'],\n                'stop-opacity': 1,\n            }),\n        ])\n    }\n\n    renderViewport(ctx) {\n        let time = this.time,\n            g = new G({ class: 'wallclockLocator' }),\n            time_x = this.timeline.positionDate(time)\n\n        // Past indicator. Only non-spacer zones are covered, to increase the look near the sidebar\n        if (this.opts.markPast) {\n            let pastG = new G({ class: 'wallclockLocatorPast' }),\n                zone_x = ctx.x + this.timeline.positionDate(this.timeline.loadStart),\n                zone_y = ctx.lead,\n                zoneWidth = Math.max(this.timeline.pointsBetween(this.timeline.loadStart, time), 0),\n                zoneHeight = 0\n            for (let [idx, el] of ctx.enabledContributions.entries()) {\n                if (idx === ctx.enabledContributions.length - 1) {\n                    zoneHeight += el.height\n                }\n                if (el.type === 'SpacerBand' || idx === ctx.enabledContributions.length - 1) {\n                    pastG.addChild(new Rect({\n                        x: zone_x,\n                        y: zone_y,\n                        width: zoneWidth,\n                        height: zoneHeight,\n                        fill: this.style['pastBackgroundColor'],\n                        'fill-opacity': this.style['pastBackgroundOpacity'],\n                        'pointer-events': 'none',\n                    }))\n                    zone_y += zoneHeight + el.height + ctx.lead\n                    zoneHeight = 0\n                } else {\n                    zoneHeight += el.height\n                }\n            }\n            g.addChild(pastG)\n        }\n\n        g.addChild(new G({ class: 'wallclockLocatorLine' }, [\n            new Line({\n                x1: ctx.x + time_x,\n                y1: ctx.lead + this.style['knobRadius'],\n                x2: ctx.x + time_x,\n                y2: ctx.total_height - ctx.trail - this.style['knobRadius'],\n                stroke: this.style['lineColor'],\n                'stroke-width': this.style['lineWidth'],\n                'stroke-opacity': this.style['lineOpacity'],\n                'stroke-dasharray': '4 3',\n                'pointer-events': 'none',\n            }),\n            new Ellipse({\n                cx: ctx.x + time_x,\n                cy: ctx.lead,\n                rx: this.style['knobRadius'],\n                ry: this.style['knobRadius'],\n                fill: `url(#${this.locatorKnobGradientId})`,\n            }),\n            new Ellipse({\n                cx: ctx.x + time_x,\n                cy: ctx.total_height - ctx.trail,\n                rx: this.style['knobRadius'],\n                ry: this.style['knobRadius'],\n                fill: `url(#${this.locatorKnobGradientId})`,\n            }),\n        ]))\n        return g\n    }\n\n    postRender(svgEl) {\n        this.wallclockLocatorLineEl = svgEl.getElementsByClassName('wallclockLocatorLine')[0]\n        this.wallclockLocatorPastEl = svgEl.getElementsByClassName('wallclockLocatorPast')[0]\n        this.clockUpdater = new LocalTimeProvider(this)\n    }\n\n    tearDown() {\n        if (this.clockUpdater) {\n            this.clockUpdater.stop()\n            this.clockUpdater = undefined\n        }\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/core/WallclockLocator.js","/*global module */\n\nimport Timeline from './Timeline'\nimport { baseTheme, darkTheme } from './theme'\nimport * as utils from './utils'\nimport * as core from './core'\nimport * as space from './space'\nimport {\n    ClipPath,\n    Defs,\n    Desc,\n    Ellipse,\n    G,\n    Line,\n    Path,\n    Pattern,\n    Tag,\n    RadialGradient,\n    Rect,\n    Set,\n    Stop,\n    Svg,\n    Text,\n    Title,\n} from './tags'\n\nlet plugins = {},\n    themes = {}\n\nregisterPlugin(core.EventBand)\nregisterPlugin(core.SpacerBand)\nregisterPlugin(core.LocationTracker)\nregisterPlugin(core.NoDataZone)\nregisterPlugin(core.EventTracker)\nregisterPlugin(core.WallclockLocator)\nregisterPlugin(core.Timescale)\n\nregisterPlugin(space.AttitudeBand)\nregisterPlugin(space.CommsBand)\nregisterPlugin(space.DayNightBand)\nregisterPlugin(space.OrbitNumberBand)\nregisterPlugin(space.SaaBand)\n\nregisterTheme(baseTheme)\nregisterTheme(darkTheme)\n\n/**\n * Registers a plugin with this module.\n */\nfunction registerPlugin(plugin) {\n    plugins[plugin['type']] = plugin\n}\n\n/**\n * Registers a theme with this module.\n */\nfunction registerTheme(theme) {\n    themes[theme['type']] = {\n        type: theme['type'],\n        rules: Object.assign({}, baseTheme['rules'], theme['rules']),\n        filters: baseTheme['filters'].concat(theme['filters'] || []),\n        defs: baseTheme['defs'].concat(theme['defs'] || []),\n    }\n}\n\nlet wrapper = function (el, opts) {\n    return new Timeline(el, Object.assign({\n        theme: 'base',\n        zoom: Timeline.defaultZoom,  // The higher, the more zoomed in\n        initialDate: new Date(),\n        tracker: 'location',\n        nodata: true,\n        wallclock: true,\n        data: [],\n    }, opts), plugins, themes)\n}\nwrapper.addDays = utils.addDays\nwrapper.isAfter = utils.isAfter\nwrapper.isBefore = utils.isBefore\nwrapper.toDate = utils.toDate\nwrapper.registerPlugin = registerPlugin\nwrapper.registerTheme = registerTheme\n\n// Expose API for use by external plugins and addons, this is mainly to be compatible with pre-ES6 code\nwrapper.ClipPath = ClipPath\nwrapper.Defs = Defs\nwrapper.Desc = Desc\nwrapper.Ellipse = Ellipse\nwrapper.G = G\nwrapper.Line = Line\nwrapper.Path = Path\nwrapper.Pattern = Pattern\nwrapper.Tag = Tag\nwrapper.RadialGradient = RadialGradient\nwrapper.Rect = Rect\nwrapper.Set = Set\nwrapper.Stop = Stop\nwrapper.Svg = Svg\nwrapper.Text = Text\nwrapper.Title = Title\n\nwrapper.EventBand = core.EventBand\nwrapper.EventTracker = core.EventTracker\nwrapper.SpacerBand = core.SpacerBand\nwrapper.LocationTracker = core.LocationTracker\nwrapper.NoDataZone = core.NoDataZone\nwrapper.WallclockLocator = core.WallclockLocator\nwrapper.Timescale = core.Timescale\n\nwrapper.AttitudeBand = space.AttitudeBand\nwrapper.CommsBand = space.CommsBand\nwrapper.DayNightBand = space.DayNightBand\nwrapper.DayNightBackgroundAddon = space.DayNightBackgroundAddon\nwrapper.OrbitNumberBand = space.OrbitNumberBand\nwrapper.SaaBand = space.SaaBand\n\nmodule.exports = wrapper\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","import { Ellipse, G, Line, Rect, Set, Text, Title } from '../tags'\nimport { toDate, isAfter, isBefore } from '../utils'\nimport Band from '../core/Band'\n\nlet leftTextMargin = 20\n\n\n/**\n * Attitude of a vehicle. Center dots indicate a change\n */\nexport default class AttitudeBand extends Band {\n\n    static get type() {\n        return 'AttitudeBand'\n    }\n\n    static get rules() {\n        return {\n            dotColor: '#000',\n            dotRadius: 2,\n            connectorColor: 'grey',\n            textColor: 'grey',\n            highlightOpacity: 0.2,\n            eventHoverBackground: '#e2e2e2',\n            dark: {\n                dotColor: '#fff',\n            },\n        }\n    }\n\n    constructor(timeline, opts, style) {\n        super(timeline, opts, style)\n\n        this.events = opts.events || []\n        this.hatchUncovered = (opts.hatchUncovered !== false)\n        this.interactive = (opts.interactive === true)\n        this.lines = this.spreadAcrossLines(this.events)\n        this.lineHeight = style['bandHeight']\n        this.bandHeight = Math.max(this.lineHeight, this.lineHeight * this.lines.length)\n    }\n\n    /**\n     * Attitude changes are not overlapping by themselves.\n     * However, the labels could still overlap.\n     */\n    spreadAcrossLines(events) {\n        let lines = []\n        for (let event of events) {\n            let start = toDate(event.start),\n                stop = toDate(event.stop),\n                fm = this.timeline.getFontMetrics(event.attitude, this.style['textSize'])\n\n            // Only consider if somehow visible within load range\n            if (isBefore(start, this.timeline.loadStop) && isAfter(stop, this.timeline.loadStart)) {\n                let inserted = false,\n                    start_x = this.timeline.positionDate(start),\n                    stop_x = start_x + leftTextMargin + fm['width']\n                for (let line of lines) {\n                    let min = 0,\n                        max = line.length - 1\n                    while (min <= max) {\n                        let mid = Math.floor((min + max) / 2),\n                            midFm = this.timeline.getFontMetrics(line[mid].attitude, this.style['textSize']),\n                            mid_start_x = this.timeline.positionDate(toDate(line[mid].start)),\n                            mid_stop_x = mid_start_x + leftTextMargin + midFm['width']\n                        if (stop_x <= mid_start_x) {\n                            max = mid - 1 // Put cursor before mid\n                        } else if (start_x >= mid_stop_x) {\n                            min = mid + 1 // Put cursor after mid\n                        } else {\n                            break // Overlap\n                        }\n                    }\n                    if (min > max) {\n                        line.splice(min, 0, event)\n                        inserted = true\n                        break\n                    }\n                }\n\n                if (!inserted) {\n                    lines.push([event]) // A new line\n                }\n            }\n        }\n        return lines\n    }\n\n    overlaps(needle) {\n        let needleStart = this.timeline.positionDate(toDate(needle.start)),\n            fm = this.timeline.getFontMetrics(needle.attitude, this.style['textSize']),\n            needleStop = needleStart + leftTextMargin + fm['width']\n        for (let hay of this.events) {\n            if (needle !== hay) {\n                let otherStart = this.timeline.positionDate(toDate(hay.start))\n                let otherFm = this.timeline.getFontMetrics(hay.attitude, this.style['textSize'])\n                let otherStop = otherStart + leftTextMargin + otherFm['width']\n                if (needleStart < otherStop && needleStop > otherStart) {\n                    return true\n                }\n            }\n        }\n        return false\n    }\n\n    get height() {\n        return this.bandHeight\n    }\n\n    renderViewport(ctx) {\n        let g = new G()\n\n        if (this.hatchUncovered) {\n            g.addChild(new Rect({\n                x: ctx.x + this.timeline.positionDate(this.timeline.loadStart),\n                y: ctx.y,\n                width: this.timeline.pointsBetween(this.timeline.loadStart, this.timeline.loadStop),\n                height: this.height,\n                fill: this.style['hatchFill'],\n                'pointer-events': 'none',\n            }))\n        }\n\n        for (let line of this.lines) {\n            for (let event of line) {\n                let start = toDate(event.start),\n                    stop = toDate(event.stop),\n                    id = this.timeline.nextId()\n\n                let bgRect = new Rect({\n                    id: id,\n                    x: ctx.x + this.timeline.positionDate(start),\n                    y: ctx.y,\n                    width: this.timeline.pointsBetween(start, stop),\n                    height: this.height,\n                    fill: this.style['bandBackgroundColor'],\n                })\n                if (event.tooltip) {\n                    bgRect.addChild(new Title({}, event.tooltip))\n                }\n                g.addChild(bgRect)\n\n                if (this.interactive) {\n                    bgRect.setAttribute('cursor', this.style['highlightCursor'])\n                    bgRect.addChild(new Set({\n                        attributeName: 'fill',\n                        to: this.style['eventHoverBackground'],\n                        begin: 'mouseover',\n                        end: 'mouseout',\n                    }))\n                    this.timeline.registerInteractionTarget(id, event, this.type)\n                }\n            }\n        }\n\n        // Second pass for adding content (this ensures they are on top of background fill)\n        for (let [idx, line] of this.lines.entries()) {\n            let offsetY = ctx.y + (idx * this.lineHeight)\n            for (let event of line) {\n                let start = toDate(event.start),\n                    startX = ctx.x + this.timeline.positionDate(start) + leftTextMargin,\n                    stop = toDate(event.stop),\n                    fm = this.timeline.getFontMetrics(event.attitude, this.style['textSize'])\n\n                let textY = ctx.y + (this.bandHeight / 2)\n                if (this.overlaps(event)) {\n                    textY = offsetY + (this.lineHeight / 2)\n                }\n\n                // Connector between dot and text\n                g.addChild(new Line({\n                    x1: ctx.x + this.timeline.positionDate(start),\n                    y1: ctx.y + (this.height / 2),\n                    x2: startX - 3, // The 3 is some small breather room\n                    y2: textY,\n                    stroke: this.style['connectorColor'],\n                }))\n\n                // Add text directly after start divider\n                g.addChild(new Text({\n                    x: startX,\n                    y: textY,\n                    fill: this.style['textColor'],\n                    'text-anchor': 'left',\n                    'dominant-baseline': 'middle',\n                    'font-size': this.style['textSize'],\n                    'pointer-events': 'none',\n                }, event.attitude))\n\n                // Start dot\n                if (!isBefore(start, this.timeline.loadStart)) {\n                    g.addChild(new Ellipse({\n                        cx: ctx.x + this.timeline.positionDate(start),\n                        cy: ctx.y + (this.bandHeight / 2),\n                        rx: this.style['dotRadius'],\n                        ry: this.style['dotRadius'],\n                        fill: this.style['dotColor'],\n                    }))\n                }\n\n                let distance = this.timeline.pointsBetween(start, stop)\n\n                // Repeat while we fit in the load range.\n                // Intentionally not using an svg pattern because we don't want anything clipped.\n                if (distance > 2 * fm['width']) {\n                    let maxTextStart = startX + this.timeline.pointsBetween(start, stop) - (2 * fm['width'])\n                    startX += 2 * fm['width']\n                    while (startX <= maxTextStart) {\n                        g.addChild(new Text({\n                            x: startX,\n                            y: ctx.y + (this.height / 2),\n                            fill: this.style['textColor'],\n                            'text-anchor': 'left',\n                            'dominant-baseline': 'middle',\n                            'font-size': this.style['textSize'],\n                            'pointer-events': 'none',\n                        }, event.attitude))\n                        startX += 2 * fm['width']\n                    }\n                }\n            }\n        }\n\n        return g\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/space/AttitudeBand.js","import { G, Rect, Set, Title } from '../tags'\nimport { toDate, isAfter, isBefore } from '../utils'\nimport Band from '../core/Band'\n\n\n/**\n * Band indicating availability of one or more communication bands.\n */\nexport default class CommsBand extends Band {\n\n    static get type() {\n        return 'CommsBand'\n    }\n\n    static get rules() {\n        return {\n            topMargin: 0,\n            bottomMargin: 0,\n            highlightOpacity: 0.7,\n        }\n    }\n\n    constructor(timeline, opts, style) {\n        super(timeline, opts, style)\n\n        this.name = opts.label || 'Comms'\n        this.interactive = (opts.interactive === true)\n        this.commsBands = opts.bands || []\n        this.events = opts.events || []\n    }\n\n    renderViewport(ctx) {\n        let g = new G(),\n            barHeight = (this.height - this.style['topMargin'] - this.style['bottomMargin']) / this.commsBands.length\n\n        for (let event of this.events) {\n            let start = toDate(event.start),\n                stop = toDate(event.stop)\n\n            // Only render if somehow visible within load range\n            if (isBefore(start, this.timeline.loadStop) && isAfter(stop, this.timeline.loadStart)) {\n                for (let [idx, commsBand] of this.commsBands.entries()) {\n                    if (event[commsBand['type']]) {\n                        let id = this.timeline.nextId()\n                        let bgRect = new Rect({\n                            id: id,\n                            x: ctx.x + this.timeline.positionDate(start),\n                            y: ctx.y + this.style['topMargin'] + (idx * barHeight),\n                            width: this.timeline.pointsBetween(start, stop),\n                            height: barHeight,\n                            fill: commsBand['color'],\n                        })\n                        if (event.tooltip) {\n                            bgRect.addChild(new Title({}, event.tooltip))\n                        }\n                        g.addChild(bgRect)\n\n                        if (this.interactive) {\n                            bgRect.setAttribute('cursor', this.style['highlightCursor'])\n                            bgRect.addChild(new Set({\n                                attributeName: 'opacity',\n                                to: this.style['highlightOpacity'],\n                                begin: 'mouseover',\n                                end: 'mouseout',\n                            }))\n                            this.timeline.registerInteractionTarget(id, event, this.type)\n                        }\n                    }\n                }\n            }\n        }\n\n        return g\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/space/CommsBand.js","import { G, Rect } from '../tags'\nimport { toDate, isAfter, isBefore } from '../utils'\n\n/**\n * Renderer to be added to a band contribution.\n * Will highlight orbital night periods based on another contribution of type DayNightBand\n */\nexport default class DayNightBackgroundAddon {\n\n    renderViewportOverlay(ctx, contribution, timeline) {\n        let g = new G()\n        for (let c of ctx.contributions) {\n            if (c['type'] === 'DayNightBand') {\n                for (let event of c['opts']['events']) {\n                    if (!event.day) {\n                        let start = toDate(event.start),\n                            stop = toDate(event.stop)\n                        if (isBefore(start, timeline.loadStop) && isAfter(stop, timeline.loadStart)) {\n                            g.addChild(new Rect({\n                                x: ctx.x + timeline.positionDate(start),\n                                y: ctx.y,\n                                width: timeline.pointsBetween(start, stop),\n                                height: contribution.height,\n                                fill: 'black',\n                                'fill-opacity': 0.08,\n                                'pointer-events': 'none',\n                            }))\n                        }\n                    }\n                }\n            }\n        }\n        return g\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/space/DayNightBackgroundAddon.js","import { G, Line, Rect, Set, Title } from '../tags'\nimport { toDate, isAfter, isBefore } from '../utils'\nimport Band from '../core/Band'\n\n\n/**\n * Day/Night terminator band\n * Indicates sun visibility.\n */\nexport default class DayNightBand extends Band {\n\n    static get type() {\n        return 'DayNightBand'\n    }\n\n    static get rules() {\n        return {\n            dayColor: '#fff',\n            nightColor: '#000',\n            cursor: 'pointer',\n            dayHoverColor: '#e0e0e0',\n            nightHoverColor: 'grey',\n            dividerColor: '#aaa',\n            dark: {\n                dayColor: '#bbb',\n            },\n        }\n    }\n\n    constructor(timeline, opts, style) {\n        super(timeline, opts, style)\n\n        this.hatchUncovered = (opts.hatchUncovered !== false)\n        this.interactive = (opts.interactive === true)\n        this.interactiveDays = (opts.interactiveDays === true)\n        this.events = opts.events || []\n    }\n\n    renderViewport(ctx) {\n        let g = new G()\n\n        if (this.hatchUncovered) {\n            g.addChild(new Rect({\n                x: ctx.x + this.timeline.positionDate(this.timeline.loadStart),\n                y: ctx.y,\n                width: this.timeline.pointsBetween(this.timeline.loadStart, this.timeline.loadStop),\n                height: this.height,\n                fill: this.style['hatchFill'],\n                'pointer-events': 'none',\n            }))\n        }\n\n        for (let [idx, event] of this.events.entries()) {\n            let start = toDate(event.start),\n                stop = toDate(event.stop),\n                id = this.timeline.nextId()\n\n            if (isBefore(start, this.timeline.loadStop) && isAfter(stop, this.timeline.loadStart)) {\n                let bgRect = new Rect({\n                    id: id,\n                    x: ctx.x + this.timeline.positionDate(start),\n                    y: ctx.y,\n                    width: this.timeline.pointsBetween(start, stop),\n                    height: this.height,\n                    fill: (event.day ? this.style['dayColor'] : this.style['nightColor']),\n                })\n                if (event.tooltip) {\n                    bgRect.addChild(new Title({}, event.tooltip))\n                }\n                g.addChild(bgRect)\n\n                if (this.interactive) {\n                    if (!event.day || this.interactiveDays) {\n                        bgRect.setAttribute('cursor', this.style['cursor'])\n                        bgRect.addChild(new Set({\n                            attributeName: 'fill',\n                            to: (event.day ? this.style['dayHoverColor'] : this.style['nightHoverColor']),\n                            begin: 'mouseover',\n                            end: 'mouseout',\n                        }))\n                        this.timeline.registerInteractionTarget(id, event, this.type)\n                    }\n                }\n\n                // Vertical start divider\n                if (!isBefore(start, this.timeline.loadStart)) {\n                    g.addChild(new Line({\n                        x1: ctx.x + this.timeline.positionDate(start),\n                        y1: ctx.y,\n                        x2: ctx.x + this.timeline.positionDate(start),\n                        y2: ctx.y + this.height,\n                        stroke: this.style['dividerColor'],\n                    }))\n                }\n\n                // Only draw stop divider if this is the last period\n                if (idx === this.events.length - 1 && isBefore(stop, this.timeline.loadStop)) {\n                    g.addChild(new Line({\n                        x1: ctx.x + this.timeline.positionDate(stop),\n                        y1: ctx.y,\n                        x2: ctx.x + this.timeline.positionDate(stop),\n                        y2: ctx.y + this.height,\n                        stroke: this.style['dividerColor'],\n                    }))\n                }\n            }\n        }\n        return g\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/space/DayNightBand.js","import { G, Line, Rect, Set, Text, Title } from '../tags'\nimport { toDate, isAfter, isBefore } from '../utils'\nimport Band from '../core/Band'\n\n/**\n * Band showing Orbit Numbers.\n */\nexport default class OrbitNumberBand extends Band {\n\n    static get type() {\n        return 'OrbitNumberBand'\n    }\n\n    static get rules() {\n        return {\n            backgroundColor: '#f5f5f5',\n            textColor: 'grey',\n            dividerColor: '#aaa',\n            cursor: 'pointer',\n            eventHoverBackground: '#e0e0e0',\n            dark: {\n                backgroundColor: '#2b2b2b',\n            },\n        }\n    }\n\n    constructor(timeline, opts, style) {\n        super(timeline, opts, style)\n        this.hatchUncovered = (opts.hatchUncovered !== false)\n        this.interactive = (opts.interactive === true)\n        this.events = opts.events || []\n    }\n\n    renderViewport(ctx) {\n        let g = new G()\n\n        if (this.hatchUncovered) {\n            g.addChild(new Rect({\n                x: ctx.x + this.timeline.positionDate(this.timeline.loadStart),\n                y: ctx.y,\n                width: this.timeline.pointsBetween(this.timeline.loadStart, this.timeline.loadStop),\n                height: this.height,\n                fill: this.style['hatchFill'],\n                'pointer-events': 'none',\n            }))\n        }\n\n        for (let [idx, event] of this.events.entries()) {\n            let start = toDate(event.start),\n                stop = toDate(event.stop)\n\n            // Only render if somehow visible within load range\n            if (isBefore(start, this.timeline.loadStop) && isAfter(stop, this.timeline.loadStart)) {\n\n                let id = this.timeline.nextId(),\n                    event_g = new G({ id: id }),\n                    eventFill = event.backgroundColor || this.style['backgroundColor']\n\n                // BG to cover hatch, and detect interaction\n                let bgRect = new Rect({\n                    x: ctx.x + this.timeline.positionDate(start),\n                    y: ctx.y,\n                    width: this.timeline.pointsBetween(start, stop),\n                    height: this.height,\n                    fill: eventFill,\n                })\n                event_g.addChild(bgRect)\n                if (event.tooltip) {\n                    event_g.addChild(new Title({}, event.tooltip))\n                }\n\n                if (this.interactive) {\n                    event_g.setAttribute('cursor', this.style['highlightCursor'])\n                    bgRect.addChild(new Set({\n                        attributeName: 'fill',\n                        to: this.style['eventHoverBackground'],\n                        begin: 'mouseover',\n                        end: 'mouseout',\n                    }))\n                    this.timeline.registerInteractionTarget(id, event, this.type)\n                }\n\n                // Vertical start divider\n                if (!isBefore(start, this.timeline.loadStart)) {\n                    event_g.addChild(new Line({\n                        x1: ctx.x + this.timeline.positionDate(start),\n                        y1: ctx.y,\n                        x2: ctx.x + this.timeline.positionDate(start),\n                        y2: ctx.y + this.height,\n                        stroke: this.style['dividerColor'],\n                    }))\n                }\n\n                // Only draw stop divider if this is the last period\n                if (idx === this.events.length - 1 && isBefore(stop, this.timeline.loadStop)) {\n                    event_g.addChild(new Line({\n                        x1: ctx.x + this.timeline.positionDate(stop),\n                        y1: ctx.y,\n                        x2: ctx.x + this.timeline.positionDate(stop),\n                        y2: ctx.y + this.height,\n                        stroke: this.style['dividerColor'],\n                    }))\n                }\n\n                let label = event.number,\n                    fm = this.timeline.getFontMetrics(label, this.style['textSize']),\n                    eventWidth = this.timeline.pointsBetween(start, stop)\n\n                // Draw label only if it fits in the box\n                if (fm['width'] <= eventWidth) {\n                    event_g.addChild(new Text({\n                        x: ctx.x + this.timeline.positionDate(start) + (eventWidth / 2),\n                        y: ctx.y + (this.height / 2),\n                        fill: this.style['textColor'],\n                        'text-anchor': 'middle',\n                        'dominant-baseline': 'middle',\n                        'font-size': this.style['textSize'],\n                        'pointer-events': 'none',\n                    }, label))\n                }\n\n                g.addChild(event_g)\n            }\n        }\n\n        return g\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/space/OrbitNumberBand.js","import { G, Line, Rect, Title } from '../tags'\nimport { toDate, isAfter, isBefore } from '../utils'\nimport Band from '../core/Band'\n\n/**\n * South Atlantic Anomaly (SAA) band.\n * Indicates periods of high radiation on-board ISS\n */\nexport default class SaaBand extends Band {\n\n    static get type() {\n        return 'SaaBand'\n    }\n\n    static get rules() {\n        return {\n            lineColor: '#c13f37',\n            lineWidth: 2,\n            whiskerColor: '#c13f37',\n            whiskerHeight: 5,\n            whiskerWidth: 2,\n        }\n    }\n\n    constructor(timeline, opts, style) {\n        super(timeline, opts, style)\n        this.events = opts.events || []\n        this.interactive = (opts.interactive === true)\n    }\n\n    renderViewport(ctx) {\n        let g = new G(),\n            whiskerLead = (this.height - this.style['whiskerHeight']) / 2\n\n        for (let event of this.events) {\n            let start = toDate(event.start),\n                stop = toDate(event.stop)\n\n            // Only render if somehow visible within load range\n            if (isBefore(start, this.timeline.loadStop) && isAfter(stop, this.timeline.loadStart)) {\n                let id = this.timeline.nextId()\n                g.addChild(new G({\n                    id: id,\n                }, [\n                    new Rect({\n                        x: ctx.x + this.timeline.positionDate(start),\n                        y: ctx.y,\n                        width: this.timeline.pointsBetween(start, stop),\n                        height: this.height,\n                        opacity: 0,\n                    }),\n                    new Line({\n                        x1: ctx.x + this.timeline.positionDate(start),\n                        y1: ctx.y + whiskerLead,\n                        x2: ctx.x + this.timeline.positionDate(start),\n                        y2: ctx.y + this.height - whiskerLead,\n                        stroke: this.style['whiskerColor'] || this.style['lineColor'],\n                        'stroke-width': this.style['whiskerWidth'] || this.style['lineWidth'],\n                    }),\n                    new Line({\n                        x1: ctx.x + this.timeline.positionDate(stop),\n                        y1: ctx.y + whiskerLead,\n                        x2: ctx.x + this.timeline.positionDate(stop),\n                        y2: ctx.y + this.height - whiskerLead,\n                        stroke: this.style['whiskerColor'] || this.style['lineColor'],\n                        'stroke-width': this.style['whiskerWidth'] || this.style['lineWidth'],\n                    }),\n                    new Line({\n                        x1: ctx.x + this.timeline.positionDate(start),\n                        y1: ctx.y + (this.height / 2),\n                        x2: ctx.x + this.timeline.positionDate(stop),\n                        y2: ctx.y + (this.height / 2),\n                        stroke: this.style['lineColor'],\n                        'stroke-width': this.style['lineWidth'],\n                    }),\n                ]))\n\n                if (event.tooltip) {\n                    g.addChild(new Title({}, event.tooltip))\n                }\n                if (this.interactive) {\n                    g.setAttribute('cursor', this.style['highlightCursor'])\n                    this.timeline.registerInteractionTarget(id, event, this.type)\n                }\n            }\n        }\n\n        return g\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/space/SaaBand.js","import { Path, Pattern, Tag } from '../tags'\n\nexport default {\n    type: 'base',\n    rules: {\n        bandHeight: 20,\n        divisionWidth: 20,  // Fixed-sized box for UI elements, not impacted by zoom\n        sidebarWidth: 100,\n        textColor: '#000',\n        textSize: '10px',\n        bandBackgroundColor: '#f5f5f5',\n        bandBackgroundFilter: 'url(#defaultShadow)',\n        bandDividerHeight: 1,\n        sidebarBackgroundColor: '#e9e9e9',\n        sidebarBackgroundFilter: 'url(#defaultShadow)',\n        sidebarForegroundColor: 'grey',\n        hatchFill: 'url(#crossHatch)',\n        highlightCursor: 'pointer',\n    },\n    filters: [\n        new Tag('filter', { id: 'defaultShadow', width: 1.5, height: 1.5, x: -.25, y: -.25 }, [\n            new Tag('feGaussianBlur', { in: 'SourceAlpha', stdDeviation: 2, result: 'blur' }),\n            new Tag('feColorMatrix', {\n                result: 'bluralpha',\n                type: 'matrix',\n                values:  `1 0 0 0  0\n                          0 1 0 0  0\n                          0 0 1 0  0\n                          0 0 0 0.3  0`,\n            }),\n            new Tag('feOffset', { id: 'bluralpha', dx: 1, dy: 1, result: 'offsetBlur' }),\n            new Tag('feMerge', {}, [\n                new Tag('feMergeNode', { in: 'offsetBlur'}),\n                new Tag('feMergeNode', { in: 'SourceGraphic'}),\n            ]),\n        ]),\n    ],\n    defs: [\n        new Pattern({\n            id: 'crossHatch',\n            patternUnits: 'userSpaceOnUse',\n            x: 0, y: 0, width: 15, height: 15,\n        }, [\n            new Path({\n                d: 'M0,0 l15,15 M15,0 l-15,15',\n                stroke: '#ddd',\n                'stroke-width': 1,\n            }),\n        ]),\n    ],\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/theme/baseTheme.js","import { Path, Pattern, Tag } from '../tags'\n\nexport default {\n    type: 'dark',\n    rules: {\n        bandBackgroundColor: '#2b2b2b',\n        bandBackgroundFilter: 'url(#darkShadow)',\n        sidebarBackgroundColor: '#3c3f41',\n        sidebarBackgroundFilter: 'url(#darkShadow)',\n        sidebarForegroundColor: 'grey',\n        textColor: '#bbb',\n        hatchFill: 'url(#darkHatch)',\n    },\n    filters: [\n        new Tag('filter', { id: 'darkShadow', width: 1.5, height: 1.5, x: -.25, y: -.25 }, [\n            new Tag('feGaussianBlur', { in: 'SourceAlpha', stdDeviation: 2, result: 'blur' }),\n            new Tag('feColorMatrix', {\n                result: 'bluralpha',\n                type: 'matrix',\n                values: `1 0 0 0  0\n                         0 1 0 0  0\n                         0 0 1 0  0\n                         0 0 0 1  0`,\n            }),\n            new Tag('feOffset', { id: 'bluralpha', dx: 2, dy: 2, result: 'offsetBlur' }),\n            new Tag('feMerge', {}, [\n                new Tag('feMergeNode', { in: 'offsetBlur'}),\n                new Tag('feMergeNode', { in: 'SourceGraphic'}),\n            ]),\n        ]),\n    ],\n    defs: [\n        new Pattern({\n            id: 'darkHatch',\n            patternUnits: 'userSpaceOnUse',\n            x: 0, y: 0, width: 15, height: 15,\n        }, [\n            new Path({\n                d: 'M0,0 l15,15 M15,0 l-15,15',\n                stroke: '#222',\n                'stroke-width': 1,\n            }),\n        ]),\n    ],\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/theme/darkTheme.js"],"sourceRoot":""}